## $Id$

## This file is part of CDS Invenio.
## Copyright (C) 2002, 2003, 2004, 2005, 2006 CERN.
##
## CDS Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## CDS Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with CDS Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

#include "cdspage.wml" \
    title="BibFormat Admin Guide" \
    navtrail_previous_links="<a class=navtrail href=<WEBURL>/admin/<lang:star: index.*.html>>_(Admin Area)_</a> &gt; <a class=navtrail href=<WEBURL>/admin/bibformat/>BibFormat Admin</a>" \
    navbar_name="admin" \
    navbar_select="bibformat-guide"

<p>Version <: print generate_pretty_revision_date_string('$Id$'); :>

<h2>Contents</h2>
<strong>1. <a href="#1">Overview</a></strong><br>
<strong>2. <a href="#2">Configuring BibFormat</a></strong><br>
<strong>3. <a href="#3">Running BibFormat</a></strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.1 <a href="#2.1">From Web interface</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.2 <a href="#2.2">From the command-line interface</a><br>
<strong>4. <a href="#4">Detailed Configuration Manual</a></strong><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.1 <a href="#4.1">About BibFormat</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.2 <a href="#4.2">How it works?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.3 <a href="#4.3">A first look at the web configuration interface</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.4 <a href="#4.4">Mapping the input (OAI Extraction Rules)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.5 <a href="#4.5">Defining output types: Behaviors</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.6 <a href="#4.6">Formats</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.7 <a href="#4.7">Knowledge bases (KBs)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.8 <a href="#4.8">User Defined Functions (UDFs)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.9 <a href="#4.9">Defining links</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.9.1 <a href="#4.9.1">EXTERNAL link conditions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.9.2 <a href="#4.9.2">INTERNAL link conditions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.9.3 <a href="#4.9.3">Example</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.10 <a href="#4.10">User management</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4.11 <a href="#4.11">Evaluation Language Reference</a></br>

<a name="1"></a><h2>1. Overview</h2>

<p>The BibFormat admin interface enables you to specify how the
bibliographic data is presented to the end user in the search
interface and search results pages.  For example, you may specify that
titles should be printed in bold font, the abstract in small italic,
etc.  Moreover, the BibFormat is not only a simple bibliographic data
<em>output formatter</em>, but also an automated <em>link
constructor</em>.  For example, from the information on journal name
and pages, it may automatically create links to publisher's site based
on some configuration rules.

<a name="2"></a><h2>2. Configuring BibFormat</h2>

<p>By default, a simple HTML format based on the most common fields
(title, author, abstract, keywords, fulltext link, etc) is defined.
You certainly want to define your own ouput formats in case you have a
specific metadata structure.

<p>Here is a short guide of what you can configure:

<blockquote>
<dl>

<dt><a href="BEH_display.php">Behaviours</a>

<dd>Define one or more output BibFormat behaviours.  These are then
passed as parameters to the BibFormat modules while executing
formatting. 

<br><em>Example:</em> You can tell BibFormat that is has to enrich the
incoming metadata file by the created format, or that it only has to
print the format out.

<dt><a href="OAIER_display.php">Extraction Rules</a>

<dd>Define how the metadata tags from input are mapped into internal
BibFormat variable names.  The variable names can afterwards be used
in formatting and linking rules.

<br><em>Example:</em> You can tell that <code>100 $a</code> field
should be mapped into <code>$100.a</code> internal variable that you
could use later.

<dt><a href="LINK_display.php">Link Rules</a> 

<dd>Define rules for automated creation of URI links from mapped
internal variables.

<br><em>Example:</em> You can tell a rule how to create a link to
People database out of the <code>$100.a</code> internal variable
repesenting author's name.  (The <code>$100.a</code> variable was mapped
in the previous step, see the Extraction Rules.)

<dt><a href="LINK_FORMAT_display.php">File Formats</a>

<dd>Define file format types based on file extensions.  This will be
used when proposing various fulltext services.

<br><em>Example:</em> You can tell that <code>*.pdf</code> files will
be treated as PDF files.  

<dt><a href="UDF_display.php">User Defined Functions (UDFs)</a>

<dd>Define your own functions that you can reuse when creating your
own output formats.  This enables you to do complex formatting without
ever touching the BibFormat core code.

<br><em>Example:</em> You can define a function how to match and
extract email addresses out of a text file.

<dt><a href="FORMAT_display.php">Formats</a>

<dd>Define the output formats, i.e. how to create the output out of
internal BibFormat variables that were extracted in a previous step.
This is the functionality you would want to configure most of the
time.  It may reuse formats, user defined functions, knowledge bases,
etc.

<br><em>Example:</em> You can tell that authors should be printed in
italic, that if there are more than 10 authors only the first three
should be printed, etc.

<dt><a href="KB_display.php">Knowledge Bases (KBs)</a>

<dd>Define one or more knowledge bases that enables you to transform
various forms of input data values into the unique standard form on
the output.

<br><em>Example:</em> You can tell that <em>Phys Rev D</em> and
<em>Physical Review D</em> are both the same journal and that these
names should be standardized to <em>Phys Rev : D</em>.

<dt><a href="test.php">Execution Test</a>

<dd>Enables you to test your formats on your sample data file.  Useful
when debugging newly created formats.

</dl>
</blockquote>

<p>To learn more on BibFormat configuration, you can consult the <a
href="guide.html">BibFormat Admin Guide</a>.

<a name="3"></a><h2>3. Running BibFormat</h2>

<a name="3.1"></a><h3>3.1. From the Web interface</h3>
<p>
Run <a href="BIBREFORMAT_display.php">Reformat Records</a> tool.
This tool permits you to update stored formats for bibliographic records.
<br>
It should normally be used after configuring BibFormat's
<a href="BEH_display.php">Behaviours</a> and
<a href="FORMAT_display.php">Formats</a>.
When these are ready, you can choose to rebuild formats for selected
collections or you can manually enter a search query and the web interface
will accomplish all necessary formatting steps.
<br>
<em>Example:</em> You can request Photo collections to have their HTML 
brief formats rebuilt, or you can reformat all the records written by Ellis.

<a name="3.2"></a><h3>3.2. From the command-line interface</h3>

<p>Consider having an XML MARC data file that is to be uploaded into
the CDS Invenio.  (For example, it might have been harvested from other
sources and processed via <a href="../bibconvert/">BibConvert</a>.)
Having configured BibFormat and its default output type behaviour, you
would then run this file throught BibFormat as follows:

<blockquote>
<pre>
$ bibformat < /tmp/sample.xml > /tmp/sample_with_fmt.xml
</pre>
</blockquote>

that would create default HTML formats and would "enrich" the input
XML data file by this format.  (You would then continue the upload
procedure by calling successively <a
href="../bibupload/">BibUpload</a> and <a
href="../bibwords/">BibWords</a>.)

<p>Now consider a different situation.  You would like to add a new
possible format, say "HTML portfolio" and "HTML captions" in order to
nicely format multiple photographs in one page.  Let us suppose that
these two formats are called <code>hp</code> and <code>hc</code> and
are already loaded in the <code>collection_format</code> table.
(TODO: describe how this is done via WebAdmin.)  You would then
proceed as follows: firstly, you would prepare the corresponding <a
href="BEH_display.php">output behaviours</a> called <code>HP</code>
and <code>HC</code> (TODO: note the uppercase!) that would not enrich
the input file but that would produce an XML file with only
<code>001</code> and <code>FMT</code> tags.  (This is in order not to
update the bibliographic information but the formats only.)  You would
also prepare corresponding <a href="FORMAT_display.php">formats</a>
at the same time.  Secondly, you would launch the formatting as
follows:

<blockquote>
<pre>
$ bibformat otype=HP,HC < /tmp/sample.xml > /tmp/sample_fmts_only.xml
</pre>
</blockquote>

that should give you an XML file containing only 001 and FMT tags.
Finally, you would upload the formats:

<blockquote>
<pre>
$ bibupload < /tmp/sample_fmts_only.xml
</pre>
</blockquote>

and that's it. The new formats should now appear in <a
href="<WEBURL>">WebSearch</a>.

<a name="4"></a><h2>4. Detailed Configuration Manual</h2>

<p><small>What follows is a transcription of an old
FlexElink Configuration Manual v0.3 (2002-07-31).  The text suffers
from missing screen snapshots, and the terminology may not be fully up-to-date
at places.<!--FIXME-->
</small>

<a name="4.1"></a><h3>4.1. About BibFormat</h3>

<p>BibFormat is a piece
of software that is part of the CDS Invenio (<a
href="http://cdsweb.cern.ch/">http://cdsweb.cern.ch</a>).
</p>

<p>Its mission, in few
words, is to provide a flexible mechanism to format the bibliographic records
that are shown as a result of CDS Search user queries allowing the
administrators or users customize the view of them. Besides, it offers the
possibility of using a linking system that can generate automatically all the
links included in the displayed records (fulltext access, electronic journals
reference, etc) reducing considerably maintenance.</p>

<p>To clarify this too
formal definition, we'll try to illustrate the role of BibFormat inside the CDS
Search module by showing the following figure. Please, note that this drawing
is trying to show the main role that BibFormat plays in the CDS structure and
it's quite simplified, but of course the underlying logic is a bit more
complex.</p>

<p><img src="./guide001.gif"></p>

<p>[Fig. 0]</p>

<p>As you can see, when a
user query is received, Weblib determines which records from the database match
it; then it ask BibFormat to format the obtained records. BibFormat looks at
its rule repository and for each record determines which format has to be
taken, applies the format specification and solves the possible links; gives
all this (in a formatted way) back to Weblib and it makes a nice HTML page
including the formatted results given by BibFormat among other info.</p>

<p>The good point in all
this is that anyone that has access to BibFormat rule repository is able to
modify the final appearance of a query result in the CDS Search module without
altering the logic of the search engine.</p>

<p>In order to be able to
modify this BibFormat rule repository, a web configuration interface is
provided. Trough this paper, we'll try to explain (in a friendly way and form
the user point of view) how to access this interface, how it's structured and
how to configure BibFormat trough it to achieve desired results.</p>

<a name="4.2"></a><h3>4.2. How it works?</h3>

<p>We've outlined which is
the role of BibFormat inside the CDS, so it's time now to have an overview of
how it works and how it's organized. We'll try not to be very technical,
however a few explanation about the BibFormat repository and architecture is
needed to understand how it works.</p>

<p>BibFormat, basically,
takes some bibliographic records as input and produces a formatted &amp; linked
version of them as output. By "formatted" we mean that BibFormat can produce an
output containing a transformed version of the input data (normally an HTML
view); the good part is that you can entirely specify the transformation to
apply. At the same time, by "linked" we mean that you can ask BibFormat to
include (if necessary) inside this formatted version references to some
Internet resources that are related to the data from some pre-configured rules.
</p>

<p>As an example, we could
imagine that you'd want to see the resulting records from CDS Search queries to
show their title in bold followed by their authors separated by comas. For
achieving this you'll have to go to the BibFormat configuration interface and
define a behavior for BibFormat in which you describe how to format incoming
records:</p>

<p>

<table border cellspacing="0" width="100%">
<tr>
<td>
<pre>

  "&lt;b&gt;" $title "&lt;/b&gt;"
  forall($author){
      $author separator(", ")
  }

</pre>
</td>
</tr>
</table>

<p align="center">Figure 1.-
A very first <em>Evaluation Language</em> example</p>

<p>Don't be scared!! It's a
first approach to the way BibFormat allows you to describe formats. As you can
see, BibFormat uses a special language that you'll have to learn if you want to
be able to specify formats or links; it seems difficult (as much as a
programming language) but you'll see that it's quite more easy than it seems at
first sight.</p>

<p>In the next figure, is
shown how BibFormat works internally. When BibFormat is called, it receives a
set of bibliographic records to format. It separates each record and translates
it into a set of what we call "internal variables"; these "internal variables"
are simply an internal representation of the bibliographic record; the
important thing with them is that they will be available when you have to describe
the formats. Once it has these "internal vars", the processor module looks into
the behavior repository for that one (let's say format) you've asked BibFormat
to apply (when BibFormat is called, you can indicate which of the
pre-configured behaviors to apply; this allows it to have more than one
behavior); inside this behavior you can specify which data you want to appear,
how it has to appear, some links if they exist... in other words, the format
(actually, it's something more than a format, it describes how BibFormat has to
behave for a given input; that's why we refer to it as behavior). As we've already said, you can include links
in a behavior specification; links are a special BibFormat feature that helps
you to reduce the maintenance of your formats: you can include a link in
several formats or behaviors.</p>

<p>The picture below,
describes all this explanation.</p>

<p><img src="./guide003.jpg">

<p>[Fig. 2]</p>

<p>Summarizing, BibFormat can
transform an input made up of bibliographic records in an HTML output (not only
HTML but any text-based output) according to certain pre-configured
specifications (behaviors) that you can entirely define using a certain
language.</p>

<p>Just to mention, currently
BibFormat is working taking OAI MARC XML as format for input records, but it
can be adapted to other ways of inputs (reading a database, function call, etc)
with a little of development.</p>

<a name="4.3"></a><h3>4.3. A first look at the web configuration interface</h3>

<p>BibFormat can be
configured through its configuration interface that is accessible via web. It's
made up of a bunch of web pages that present you the main configuration aspects
of BibFormat allowing you to change them. In this section we are going to have
a first look at this web interface, how it's structured and its correspondence
with BibFormat features.</p>

<p>Before entering
these web pages you'll be asked for your accessing username &amp; password.
Only certain users are allowed to access BibFormat WI; first you need a CDS
account that you can create easily by using the standard CDS account manager;
then you have to ask BibFormat administrator to give privileges to access the
WI.</p>

<p>. Once your password is accepted you'll access
the configuration interface. You'll see that is quite simple: It's structured
in different sections; each of them corresponds to a BibFormat feature and you
can navigate through them by using a navigation bar that is always present on
the left.</p>

<p>[Fig. 3]</p>

<p>Here you are a list
of the different sections the interface offers you and their correspondence
with BibFormat features:</p>

<ul>
<li><strong>Behaviors:</strong> This is the main section, the one you
enter by default when you access the web interface. It contains definitions for
the different pre-configured output types or behaviors that allow you to define
how you want BibFormat to behave when each output type is selected. More information
in chapter <em>Defining output types: Behaviors</em> of this manual.</li>

<li><strong>OAI Extraction Rules:</strong> The input types and
mapping rules for OAI MARC XML inputs are defined here. You'll find here the
information about all the internal variables and their correspondence with the
input XML tags. See chapter <em>Mapping the input</em> of this manual for more
information.</li>

<li><strong>Link Rules:</strong> Allows you to access the link rules
repository for defining the way links are generated. See chapter <em>Defining
Links</em> for a more detailed description about the BibFormat linking system.</li>

<li><strong>UDFs:</strong> Presents you a list of all the User
Defined Functions (UDFs) that you can use inside <em>Evaluation Language</em> (<em>EL</em>)
statements that are used for specifying different configuration aspects.
You'll also be able to modify or extend this list within this section.
Everything about using UDFs and defining new ones in chapter <em>User Defined
Functions (UDFs)</em>.</li>

<li><strong>Formats:</strong> Another <em>EL</em> feature: You can
define a certain piece of <em>EL</em> code under a name for re-using it whenever
you want. See chapter <em>Formats</em>.</li>

<li><strong>KBs:</strong> A complete management interface for <em>Knowledge
Bases</em> (<em>KBs</em>); those <em>KBs</em> will also be available inside <em>EL</em>
statements. See chapter <em>Knowledge Bases(Kbs)</em> for more specific
information.</li>

<li><strong>Execution Test:</strong> You'll be able to execute
BibFormat from this section and view the results and some debug info in a web
page. You have to specify an input data file (through a URL).</li>

<li><strong>User management:</strong> Allows you to define which CDS
users can access or not the BibFormat web interface.</li>

</ul>

<p>Each section has
different particularities but the way of dealing with them follows a common
line through the interface. However, each section with their common things and
particular characteristics are treated in the following chapters of this
manual.</p>

<a name="4.4"></a><h3>4.4. Mapping the input (OAI Extraction Rules)</h3>

<p>We have already spoken a bit about BibFormat <em>internal
variables</em>. These are a key point to understand the BibFormat way of
working. As you know, BibFormat takes some bibliographic records as input and,
according to some pre-configured behavior, formats them into HTML, for example.
The problem is that this input records can come in several formats: different
XML conventions, database records, etc. For now, at CDS we only consider that
the input comes in OAI MARC XML but for the near future we'll may be have to
extend it to accept other input formats.</p>

<p>That's the reason why <em>internal variables</em> appear; they
provide a common way to refer to input data without relaying in any concrete
format. In other words, we will define BibFormat links and behaviors referring
to these <em>internal variables</em> and we'll have some rules that define how to
map an input format to them, so we would be able to use any BibFormat defined
behavior with any input that can be mapped to <em>internal variables</em>.</p>

<p><img src="./guide004.gif"></p>

<p>[Fig. 4]</p>

<p>You shouldn't worry about this because is more in the
development/administration side, but it's important to know where <em>internal
variables</em> come from and what they refer to. Besides, for CDS we only
consider the incoming data in OAI MARC XML format, so we'll talk only about
this case.</p>

<p><em>Internal variables</em> are quite a simple concept: It's just
a label that represents some values from the input. Besides, a variable can
have <em>fields</em> that are also labels that represent values from the input
but that are related to other under the variable (e.g. You can have a variable
that maps authors and another that maps authors home institutes independently;
but if you want to have represent an author and his home institute you need to
relate these two variables in some way). Variables and their fields also
support multiple values.</p>

<p>Focusing on OAI MARC XML, the concept of variable and field is
already in the input structure.:</p>

<ul>
<li>Each occurrence of OAI MARC XML <em>varfield</em> element
will correspond to a different variable value.</li>
<li>Each occurrence of OAI MARC XML <em>subfield</em> inside
a certain <em>varfield</em> element will correspond to a different field value of
the variable that maps the <em>varfield</em>.</li>
</ul>

<p>So what we will have in BibFormat is a set of rules that tells a
variable name to which <em>varfield</em> element corresponds and each variable
field name which <em>subfield</em> element maps. Trough the web interface you'll
be able to add or delete new fields to variables or variables themselves,
you'll be able even to modify the mapping tags of variables (this way you can
keep your formats independent of changes in the meaning of MARC tags).</p>

<p>In the web interface, all this is located in <em>OAI Ext. Rules</em>
section as you can see in the following figure:</p>

<p>[Fig. 5]</p>

<p>Let's illustrate how BibFormat maps a certain input to variables
and fields with an example:</p>

<p>We have this variable &amp; field definition on BibFormat:</p>

<p>

<table border cellspacing='0' cellpadding='5'>
<tr bgcolor='#e0e0e0'>
<th align='center'>Var.<br>label</th>
<th align='center'>Mapping tag</th>
<th align='center'>Mult. V.</th>
<th align='center'>Fields</th>
</tr>
<tr>
<td align='center'>100</td>
<td align='center'>&lt;varfield id="100" i1="" i2=""&gt;</td>
<td align='center'>Yes</td>
<td align='center'>

  <table border cellspacing='0'>
  <tr bgcolor='#e0e0e0'>
  <td align='center'>Field label</td>
  <td align='center'>Mapping tag</td>
  </tr>
  <tr>
  <td align='center'>a</td>
  <td align='center'>&lt;subfield label="a"&gt;</td>
  </tr>
  <tr>
  <td align='center'>e</td>
  <td align='center'>&lt;subfield label="e"&gt;</td>
  </tr>
  </table>

</td>
</tr>
<tr>
<td align='center'>909C0</td>
<td align='center'>&lt;varfield id="909" i1="C" i2="0"&gt;</td>
<td align='center'>No</td>
<td>

  <table border cellspacing='0'>
  <tr bgcolor='#e0e0e0'>
  <td align='center'>Field label</td>
  <td align='center'>Mapping tag</td>
  </tr>
  <tr>
  <td align='center'>b</td>
  <td align='center'>&lt;subfield label="b"&gt;</td>
  </tr>
  </table>

</td>
</tr>
</table>

<p>

<p>And then a record like the following arrives as input:</p>

<p>

<table border cellspacing="0" width="100%">
<tr>
<td>
<pre>
  &lt;oai_marc&gt;
   &lt;varfield id="037" i1="" i2=""&gt;
    &lt;subfield label="a"&gt;SCAN-0009119&lt;/subfield&gt;
   &lt;/varfield&gt;
   &lt;varfield id="100" i1="" i2=""&gt;
    &lt;subfield label="a"&gt;Racah, Giulio&lt;/subfield&gt;
   &lt;/varfield&gt;
   &lt;varfield id="100" i1="" i2=""&gt;
    &lt;subfield label="a"&gt;Guignard, G&lt;/subfield&gt;
    &lt;subfield label="e"&gt;editor&lt;/subfield&gt;
   &lt;/varfield&gt;
   &lt;varfield id="909" i1="C" i2="0"&gt;
    &lt;subfield label="b"&gt;11&lt;/subfield&gt;
   &lt;/varfield&gt;
   &lt;varfield id="909" i1="C" i2="0"&gt;
    &lt;subfield label="b"&gt;12&lt;/subfield&gt;
   &lt;/varfield&gt;
  &lt;/oai_marc&gt;
</pre>
</td>
</tr>
</table>

<p>The result of the mapping would be like this:</p>

<p>

<table border cellspacing='0' cellpadding='5' width="60%">
<col width="25%">
<col width="25%">
<col width="25%">
<col width="25%">
<tr bgcolor='#e0e0e0'>
<th align='center' colspan='4'>Variable "100"</th>
</tr>
<tr>
<td align='center' bgcolor='#e0e0e0'>Value# 0</td>
<td>&nbsp;</td>
<td align='center' bgcolor='#e0e0e0'>Field "a" value</td>
<td align='center'><samp>Racah, Giulio</samp></td>
</tr>
<tr>
<td align='center' rowspan='2' bgcolor='#e0e0e0'>Value# 1</td>
<td align='center' rowspan='2'>&nbsp;</td>
<td align='center' bgcolor='#e0e0e0'>Field "a" value</td>
<td align='center'><samp>Guignard, G</samp></td>
</tr>
<tr>
<td align='center' bgcolor='#e0e0e0'>Field "e" value</td>
<td align='center'><samp>editor</samp></td>
</tr>
</table>

<p>

<table border cellspacing='0' cellpadding='5' width="60%">
<col width="25%">
<col width="25%">
<col width="25%">
<col width="25%">
<tr bgcolor='#e0e0e0'>
<th align='center' colspan='4'>Variable "909C0"</th>
</tr>
<tr>
<td align='center'>Value# 0</td>
<td align='center'>&nbsp;</td>
<td align='center'>Field "b" value</td>
<td align='center'><samp>12</samp></td>
</tr>
</table>

<p>Notice how <em>varfield 037</em> is not considered because there
isn't an entry in the BibFormat configuration. Also notice how the values are
created: if "allow multiple values" is set to "Yes" each occurrence of a <em>varfield</em>
element determines a new value (variable "100"); in other case, the last value
is taken as single value for the variable (variable "909C0").</p>

<a name="4.5"></a><h3>4.5. Defining output types: Behaviors</h3>

<p>Now that we already know how internal variables are structured
and what they represent in the input, it's time to have a look at how to
configure BibFormat to transform that input data mapped into variables into
HTML results (although any text-based output could be generated).</p>

<p>When BibFormat is asked to format a bunch of bibliographic
records, it is also necessary to specify which <em>output type</em> it has to
use. This output type is a string that identifies a pre-configured set of
conditions and actions that tells BibFormat how to behave with the given input
data (that's why the terms <em>output type</em> and <em>behavior</em> are used
indifferently along this document).</p>

<p>BibFormat can have several pre-configured behaviors each one
identified by a different label. There are two different types of behaviors
(you can choose the behavior type when you define it):</p>

<ol>
<li>Normal: 
Consists in a behavior that outputs exactly the result of its evaluation.</li>
<li>Input Erich (only for XML inputs): It echoes each xml record
from the input inserting the behavior result just before the xml closing
element of the record.</li>
</ol>

<p>Each behavior contains an ordered list of conditions; a
condition can contain zero or more associated actions (actions are ordered
inside a condition). A condition is a behavior item described by an <em>Evaluation
Language</em> expression that gives as result "TRUE" or "FALSE". An action is an
<em>Evaluation Language</em> (<em>EL</em>) statement that produces any output.</p>

<p>When BibFormat is called to format a set of input records with a
given behavior label, it looks for the behavior conditions. It evaluates their <em>EL</em>
in order and when one of them produces "TRUE" as result, it looks for their
associated actions. Then BibFormat evaluates the actions in the specified order
and concatenates their result.</p>

<p>By using different conditions you can specify alternative
formats inside a behavior (imagine that you want to format a record differently
depending on its base number); it's true that you could also reach this
solution by using <em>EL IF</em> statements, but it's more clear, efficient and
re-usable (you can change one condition without touching the rest or you can
give it more priority than others, that means give it the chance to be
evaluated before others, by changing its apply order).</p>

<p>Actions are used for specifying the format itself or the actions
you want to carry on with in case the condition is accomplished.</p>

<p>Through the web interface you can define new output types or
modify the ones that already exist. The use is quite easy: you just have to
select the link in the desired item with the operation you want to do over it.</p>

<p>[Fig. 6]</p>

<p>Let's have a look at a simple example to illustrate how to
define behavior that fit our needs:</p>

<p>Imagine a typical case where you want to format bibliographic
records but depending on their base number you want to apply different formats.
Whenever a record from base 27 (standards) arrives we want only to show its
title and the standard numbers, in other case a default format will be applied
in which the title and authors are shown. We'll assume CDS variable notation
and that the input rules are defined properly.</p>

<p>We are going to define a new NORMAL behavior for this new
situation, let's call it <em>SIMPLE</em>. In it we'll need two conditions to be
defined: one for applying the default format and another one for the 27-base
special one. The base number comes in variable 909C0.b, so the conditions would
be based on this variable content.</p>

<p>The result behavior should be defined like this:</p>

<p>

<table border cellspacing='0' width="60%">
<tr>
<th align='center' colspan='2' bgcolor='#a0a0a0'>SIMPLE<small>(NORMAL)</small></th>
</tr>
<tr>
<td bgcolor='#e6e6e6'>10</td>
<td bgcolor='#e6e6e6'>$909C0.b="27"</td>
</tr>
<tr>
<td colspan='2'>
<pre>

"&lt;b&gt;"$245.a"&lt;/b&gt;"
forall($0248.a){
&nbsp;rep_prefix(" - ") $0248.a separator("; ")
}

</pre>
</td>
</tr>
<tr>
<td bgcolor='#e6e6e6'>50</td>
<td bgcolor='#e6e6e6'>""=""</td>
</tr>
<tr>
<td colspan='2'>
<pre>

"&lt;b"$245.a"&lt;/b&gt;"
forall($100.a){
&nbsp;rep_prefix(" - Authors:") $100.a separator("; ")
}

</pre>
</td>
</tr>
</table>

<p>

<p>Some explanations on this example are needed:</p>

<ul>
<li>As you can see we have defined two conditions: one for
the 27-format and another for the default format. The point that is important
is the order in which we put the conditions: For each record in the input the
special one is evaluated first (because it has a lower evaluation number, 10)
and if the condition is true the format will be applied; in case the base is
not 27 the default condition is evaluated and because its condition <em>EL</em> code
is always true the default will be used to format the record.</li>

<li>Don't worry too much about the action code because it's
quite trivial. There are some "strange" things like the use of functions <em>rep_prefix</em>
and <em>separator</em>. These are special <em>UDFs</em> that have a special
behavior inside a FORALL statement:

<ul>
<li><em>rep_prefix</em>: Prints the string argument only when we are in the
first iteration of a <em>FORALL</em>. In order words, put the prefix of the
string which is to be generated by the <em>FORALL</em> statement.</li>

<li><em>Separator</em>: Prints the string argument in every <em>FORALL</em>
iteration but not in the last one.</li>
</ul>
</li>
</ul>

<a name="4.6"></a><h3>4.6. Formats</h3>

<p><em>Formats</em> are a special construction that BibFormat <em>Evaluation
Language</em> (<em>EL</em>) offers. It allows you to group under an identifier
some <em>EL</em> code and after you can call it from every <em>EL</em> statement.</p>

<p>You can manage these formats using the web interface. It is
quite easy to do so: When you access the <em>Formats</em> section it will present
you a list with all the format identifiers that are already defined and a small
documentation about what's the format for. From there you can see the whole <em>EL
</em>code by using the link <em>[Code]</em>. You can add a new format by using the
set of input boxes that you'll find at the end of the page. Also delete and
modify operations are possible for already defined formats.</p>

<p>[Fig. 7]</p>

<p><strong><u>Note:</u></strong> When defining formats,
one has to pay attention not to use "recursive" format calls (either direct or
indirect); this can lead to execution problems. For example, imagine that we
have a format called "ex 1" that has a call for itself:</p>

<blockquote>
<table border cellspacing='0' width="60%">
<tr>
<td align='center'>Format "ex_1"</td>
</tr>
<tr>
<td align='center'>
<pre>
"hello world" 
format("ex_1")
</pre>
</td>
</tr>
</table>
</blockquote>

<p>this is a "direct" recursive call; you
should never have these kind of calls as the web interface should warn you if
it finds these kind of troubles. However, "indirect" calls are not detected by
the web interface, so you have to care about them. One example of "indirect"
recursion:</p>

<p>

<blockquote>
<table border cellspacing='0' width="60%">
<tr>
<td align='center'>Format "ex_1"</td>
</tr>
<tr>
<td align='center'>
<pre>
"hello world" 
format("ex_2")
</pre>
</td>
</tr>
</table>
</blockquote>

<a name="4.7"></a><h3>4.7. Knowledge bases (KBs)</h3>

<p>This is yet another special feature provided by BibFormat <em>Evaluation
Language</em>. In a few words, this allows you to map one string value to
another according to a pre-stored set of key values that map to other values
(the knowledge bases). All the knowledge bases are identified by a label that
has to be unique (among other KBs identifiers); remember that identifiers are
not case-sensitive.</p>

<p>These sets of values, normally lived in a file, but with this
new development there was the need to have an easy KB management that was
integrated in BibFormat. For this reason, you can manage KBs from the BibFormat
configuration interface: section <em>KBs</em>.</p>

<p>When accessing to <em>KBs</em> section, the list of all the KBs
identifiers defined will be displayed. Below it you'll find a set of controls
to add new KBs; the use of these controls is as usual along the interface but
there's something a bit special: Normally, you shouldn't fill in the input box
that asks you for the <em>Knowledge base table name</em>; all the knowledge base
data is handled by a database in which each KB corresponds to a DB table; this
input box gets the internal table name for that KB; normally the KB manager
will generate it for you so you shouldn't need to use it.</p>

<p>[Fig. 8]</p>

<p>Each KB has a link for accessing the list of values that it
contains. If you click on it, a new window will show you the list of current
values (key and mapped ones) and a very easy interface to add new values or to
delete existing ones (KB values are case sensitive).</p>

<p>[Fig. 9]</p>

<a name="4.8"></a><h3>4.8. User Defined Functions (UDFs)</h3>

<p>The use of <em>User Defined Functions</em> (<em>UDFs</em>) is one of
the more powerful features of BibFormat <em>Evaluation Language</em> (<em>EL</em>).
The idea is that inside <em>EL</em> you can use operations or functions over
strings; normally a large number of different string transformations are needed
when talking about formatting but we cannot pretend implement all this
operations inside <em>EL</em> because it's in constant growing and new needs
appear all the time. For dealing with this problem, BibFormat defines a
mechanism that allows you to use define as much functions (<em>UDFs</em>) as you
want and use them inside any <em>EL</em> statement.</p>

<p>These functions are identified by a unique name and they receive
data (over which they do operations) by parameters. These functions are defined
in a programming language (PHP) and therefore good knowledge of this language
is needed.</p>

<p>BibFormat offers a complete UDF management through the <em>UDFs</em>
web interface section. There you'll see a complete list of all defined <em>UDFs</em>
with their identifier, parameters and a small documentation about what the UDF
does. You can also add, delete or modify <em>UDFs</em> or even have a look at the
PHP code of an already defined function (there you'll be able to launch small
tests over the defined functions).</p>

<p>[Fig. 10]</p>

<p>The definition of these functions should be reserved to
administrators and some particularities have to be taken into account when
defining <em>UDFs</em>:</p>

<ul>
<li>When you want to add or modify a <em>UDF</em> you are
asked for the parameter list; you have to enter the parameter names separated
by comas. Ex: You want to define a new function for prefixing a given string
with another, so you need two parameters (one for the string which is going to
be prefixed, let's name it <em>str</em>, and another one for the prefix itself,
let's name it <em>prefix</em>); you should enter them in the parameter input box
like this: <em>prefix, str</em></li>

<li>The order in which you specify the parameters when
defining a function is the order in which they have to be passed to the <em>UDF</em>
from an <em>EL</em> statement.</li>

<li>When defining the PHP code of a function, there are
some important things to consider:

<ul>
<li>The result of a function has to be a string.</li>

<li>The parameters are available inside the PHP code as
variables with the parameter name.</li>

<li>The result of the function has to be defined by a PHP
result clause giving the resulting string.</li>

<li>Make sure the PHP code is correct (there's no way to
know if the code is correct from BibFormat and it won't tell you if it is).</li>

<li>There are some special variables available inside the
PHP definition:

<ul>
<li>$FIRST_ITERATION:  Is equal to "1" when we are in the first iteration
of an <em>EL FORALL</em> statement. "0" in other case. If the call is made outside
a <em>FORALL</em> is set to "1".</li>

<li>$LAST_ITERATION: Just the opposite case.</li>
</ul>

<p>With these two
variables you can define <em>FORALL</em> special functions like a function to
print a separator.</p>
</li>
</ul>
</li>
</ul>

<a name="4.9"></a><h3>4.9. Defining links</h3>

<p>As we've already said, BibFormat is not only a formatter but it
also provides a link manager but, what do we mean by 'link manager'? The idea
is to have a set of rules that describe how to generate a link using certain
data; if the link can be generated from those rules, then the link manager can
check different things (i.e. see if the link is valid, if it's a link to a file
it can check if the file exists and in which formats it exists, etc) and
finally return the solved link. In other words, if you have a set of
bibliographic records that can contain a certain link and that link can be
coded in the link manager rules, you don't need to store each link in each
bibliographic record, you just use the link manager to generate them
dynamically; like this, you only have to maintain a small set of rules and not
thousands of static links in records.</p>

<p>BibFormat allows you to configure different <em>link definitions</em>
each of them identified by a unique name; each of these <em>link definitions</em>
have some associated <em>parameters</em> which are the information passed to the
rules defined for it. Then, when you call the link manager to solve a link
(from an <em>EL</em> statement, for example) you'll have to specify the
identifier of the <em>link definition</em> you want to be used and the value for
each of the parameters used by that <em>link definition</em> (always string
values). The link manager will retrieve the rules associated to the <em>link
definition</em> specified and will interpret those rules using the given
parameter values, informing you if the link was generated correctly and result
(the solved link).</p>

<p>BibFormat provides this mechanism and through the web interface
you can access to the rule repository for having a look at what are the
available <em>link definitions</em>, define new link rules or maintain already
defined ones. When adding or modifying a <em>link definition</em> you'll have to
specify the parameters, please remember to separate them by using comas.</p>

<p>[Fig. 10]</p>

<p><em>Link definitions</em> are structurally quite similar to
behaviors: Although there can be different types of them (as we'll see later),
a <em>link definition</em> is made up of one or more conditions and each of these
conditions can have one or more actions that tell how the link has to be built
in case its condition is accomplished. In general, link rules (this includes
conditions and actions) have a particular structure and they are described in <em>Evaluation
Language</em> (<em>EL</em>) with one restriction: <em>EL LINK</em> statement
cannot be used. Each group of conditions-actions of a link definition can be of
a different <em>solving type</em> (actually, when you create a new link
definition, its <em>solving type</em> its asked; this is just because all
conditions that will be created for that link definition will have the selected
<em>solving type</em> as default; but you can change it afterwards having a
"mixed" <em>link definition</em>). Their structure and way the link manager interprets
them will depend in their <em>solving type</em>. Currently, there you can define
link conditions of two different <em>solving types</em>: EXTERNAL or INTERNAL. A
more detailed explanation about each type is given later.</p>

<p>As we've said a link definition is made up of various link
conditions. When a solving for a concrete <em>link definition</em> is asked, the
link manager retrieves all link conditions associated to it. Then it takes the
first of them (following the <em>evaluation order</em> - the lower is the
evaluation order number, the first the condition is considered), it evaluates
its <em>EL</em> code with the parameter values passed and if the result is "TRUE"
associated actions are executed, the link is returned and the solving process
finishes. In case a condition fails, it looks for the next one. If all the
conditions fail then the link manager returns that the link couldn't be solved.
This is the general behavior of the link manager, but the way of determining if
a link has been solved or not and the link building depends on the condition <em>solving
type</em>.</p>

<a name="4.9.1"></a><h4>4.9.1. EXTERNAL link conditions</h4>

<p>This is the simplest way of solving links. It's intended to be
used when you want to generate a link that points to an external resource
(normally a web page). In this case the link condition is composed by only one
action that will be evaluated if the associated condition is "TRUE". When a
condition of this type is evaluated "TRUE" and the action is executed, the
result of the action is given as the solved link and the link manager finishes.</p>

<p>[Fig. 11]</p>

<a name="4.9.2"></a><h4>4.9.2. INTERNAL link conditions</h4>

<p>This condition solving type is intended to be used when you want
to link to a document which is a file (inside or outside your file system) and
that can be in different file formats.</p>

<p>This case is a bit more complex than the previous one, so we'll
go step-by-step explaining differences and special features:</p>

<ul>
<li>An INTERNAL condition has a <em>base file path</em> and a
<em>base URL</em> associated. The <em>base file path</em> is the string that will
be used as prefix when looking for a file generated by the actions associated
to that condition. On the other hand, the <em>base URL</em> will be a string to
which the link string (resulting from the actions) will be added (i.e. if the <em>base
file path</em> of a condition is <code>/tmp/docs</code>
and the <em>base URL</em> is <code>http://doc.cern.ch/</code>,
if the condition is true and the result of the actions is <code>test.pdf</code>, the file path the link manager
will have to check will be <code>/tmp/docs/test.pdf</code>
and, if the file exists, the generated link will be <code>http:/doc.cern.ch/test.pdf</code>)</li>

<li>Any condition of this type can several associated <em>file
formats</em>. This is a new concept that is only used for INTERNAL condition
solving. A <em>file format</em> is simply a set of file extensions that are
grouped under an identifier. Then, you can associate a <em>file format</em>
identifier with a link condition. When the condition is true the link manager
will combine each result from the condition actions with the associated file
formats to check the existence of a file of any format; this means that when an
action is evaluated, the link manager takes the file extensions of each
associated file format identifier and checks if the <em>file base path</em> +
resulting action string + file extension exists in the file system.</li>

<li>One condition of this type can have more than one
associated action. Each of its actions describes an alternative way of building
the file path. When a condition of this type is evaluated to "TRUE", the link
manager retrieves its actions (following actions <em>apply order</em>) and
evaluates the first one; with the action result it builds the file path in this
way: <em>file base path</em> + resulting action string, and then combines this
string with each of the <em>file extensions</em>. If any of the combination
exists in the file system, the link is generated (if there are more than one
file format combination that exist, the link variable will have multiple values
containing the different links); if not, it starts the same process with the
next action. If any of the actions drive to a existing file, the link is not
generated.</li>

<li>When calling the link manager from a <em>EL</em>
statement (see chapter <em>Evaluation Language Reference</em>), if the link is
solved we'll be able to access to a special internal variable that contains as
value the resulting link. In the INTERNAL condition links, we have said that
this variable can contain multiple values in case the link manager finds
different file formats. In this case, there's another extension that consists
in having some special variable fields containing special values for each value
in the <em>LINK</em> variable and to which you can access when the link is solved;
here's a table detailing the different variable LINK fields which are defined
when a INTERNAL condition link is solved:</li>
</ul>

<blockquote>
<table border cellspacing='0'>
 <tr>
  <th bgcolor='#a0a0a0'>Field  name</th>
  <th bgcolor='#a0a0a0'>Value that contains</th>
 </tr>
 <tr>
  <th align='left'>url</th>
  <td>The same value as the LINK variable: The solved URL.</td>
 </tr>
 <tr>
  <th align='left'>file</th>
  <td>Contains the local full path to the file the solved URL points to.</td>
 </tr>
 <tr>
  <th align='left'>format_id</th>
  <td>Contains the file format id string</td>
 </tr>
 <tr>
  <th align='left'>format_desc</th>
  <td>Contains the file format description string (this
  is defined for each file format)</td>
 </tr>
</table>
</blockquote>

<a name="4.9.3"></a><h4>4.9.2 Example</h4>

<p>As the link generation is quite a complex topic (specially when
talking about INTERNAL linking) we'll try to illustrate it with a simple
example.</p>

<p>Let's imagine we want to create a new link definition for
generating full-text access to the documents that are archived on a document
server (a file system which contains document's electronic versions). These
documents are organized systematically depending in three characteristics that
are included in the bibliographic records: BASE, CATEGORY and ID. When the base
corresponds to "CERNREP" then the files are archived below directory <code>/pub/www/home/cernrep/</code>
and can be stored following two different criteria that depend on the CATEGORY
and ID values; the documents are all HTML. However, if the base is "PREPRINT"
and the CATEGORY is either "HEP-TH" or "HEP-PH" they are stored under directory
<code>/archive/electronic|/pub/www/home/</code> following a certain criteria; in this
case the documents can be in several file formats: PDF, Postscript, MS Word.</p>

<p>Of course, we want only the link to be created if the files
corresponding to the bibliographic records exist.</p>

<p>So we start creating a new link definition that we'll call <em>FULLTEXT</em>.
It will receive three parameters that are the information we need for
generating this kind of links: BASE, CATEGORY and ID. We select INTERNAL as
solving type as default and then we fill it the base file path and url with
some default values (these values are not important, they will be copied by
default to the conditions we are going to create afterwards).</p>

<p>[Fig. 12]</p>

<p>Then we create a condition for the first possibility: when BASE
is "CERNREP". We select INTERNAL as link condition because we want to link to a
file and we want to check its existence and we fill in the base file path and
URL with the corresponding values. Then we assign the file format types and we
enter the file archiving criteria as different actions.</p>

<p>[Fig. 13]</p>

<p>For the other possibility we proceed in the same way by adapting
the definition to the requirements; we'll have something like this as result:</p>

<p>[Fig. 14]</p>

<p>Once we have finished the link definition, we can insert links
of this type from a BibFormat behavior, for example. Let's imagine we have
included a piece of <em>EL</em> code like this in a behavior because we want to
insert a link to the full-text documents of any record:</p>

<p>

<table border cellspacing="0" width="100%">
<tr>
<td>
<pre>

link("FULLTEXT",$base, $category, $id)
{
  "Fulltext: "
  forall($link){
    "&lt;a href=\"" $link.url "\"&gt;" $link.format_desc "&lt;/a&gt;"
    separator " - "
  }
}

</pre>
</td>
</tr>
</table>

<p>This <em>EL</em> statement will include the string "Fulltext: "
followed by a link to all the documents found for the values of internal
variables $base, $category, $id separated by " - ".</p>

<p><a name="4.10"></a><h3>4.10. User management</h3>

<p>The BibFormat web interface (WI) comes with a security mechanism
which allows you to define which users can access the WI. BibFormat doesn't
have a user management incorporated; instead it uses CDS user schema (as is a
part of CDS). So if you are not registered as CDS user and you want to have
access to BibFormat WI, first thing to do is to register in CDS through the
standard procedure (for example via the CDS Search interface you can access the
CDs account management system).</p>

<p>BibFormat WI access policy is rather simple: it keeps a list of
CDS users that can access the WI. Then if someone tries to access any part of
the WI, the system will ask the user to identify him as CDS user. If the CDS
login is successful and the user is in BibFormat's access list, then the user
will gain access to the WI.</p>

<p>There's a section in the WI which allows you to define which CDS
users will have access to the WI. The use is rather simple: You can add CDS
users to the access list by specifying either their CDS user id or their CDS
login; then you can delete a CDS uses from the access list by simply selecting
the link "delete" for the corresponding user.</p>

<p>[Fig. 15]</p>

<p>When you install BibFormat for the first time and you access to
the WI you'll see that no login or password is asked. The security mechanism
doesn't get activate until at least one user is added to the BibFormat's access
list. So if you don't want to limit the access to BibFormat WI keep the access
list without any user in.</p>

<a name="4.11"></a><h4>4.11. Evaluation Language Reference</h4>

<p>In this section we'll present a more or less formal definition
of the <em>Evaluation Language</em> (EL); although we are using some formal
methods to describe it we'll also make a quick explanation about the elements
that made up the language and how to combine them to arrive to desired results.
</p>

<p>Just below you can find the EL definition, expressed in terms of
EBNF (<em>Extended Backus-Naur Form</em>) notation. We have used capital letters
to express non-terminal elements and non-capital/bold characters for the
terminal ones. There's one remark to make: Whenever you find the mark
<small><code>[REX]</code></small> after
any definition, it means that we have used a regular expression just before in
order to express a set of non-terminals.</p>

<p>

<table border cellspacing="0" width="100%">
<tr>
<td>
<pre>

 SENTENCE ::= TERM {<strong>&amp;&amp;</strong> TERM | <strong>||</strong> TERM}

 TERM ::= FACTOR {<strong>=</strong> FACTOR | <strong>!=</strong> FACTOR | FACTOR}

 FACTOR ::= [<strong>!</strong>] BASIC

 BASIC ::= VARIABLE | LITERAL | FUNCTION | <strong>(</strong> SENTENCE <strong>)</strong> | FORALL |
           IF | FORMAT | LINK | COUNT | KB

 VARIABLE ::= <strong>$</strong> STRING [<strong>.</strong> STRING]

 LITERAL ::= <strong>"([^"] | \")*"</strong> <small>[REX]</small>

 FUNCTION ::= STRING <strong>(</strong> [ SENTENCE {<strong>,</strong> SENTENCE} ] <strong>)</strong>

 FORALL ::= <strong>forall (</strong> VARIABLE [<strong>,</strong> LITERAL] <strong>) {</strong> SENTENCE <strong>}</strong>

 IF ::= <strong>if(</strong> SENTENCE <strong>) {</strong> SENTENCE <strong>}</strong> [<strong>else {</strong> SENTENCE <strong>}</strong>]

 FORMAT ::= <strong>format(</strong> SENTENCE <strong>)</strong>

 LINK ::= <strong>link(</strong> SENTENCE <strong>,</strong> [SENTENCE {<strong>,</strong> SENTENCE}] <strong>) {</strong> SENTENCE <strong>}</strong>
          [<strong>else {</strong> SENTENCE <strong>}</strong>]

 COUNT ::= <strong>count(</strong> VARIABLE <strong>)</strong>

 KB ::= <strong>kb(</strong> SENTENCE <strong>)</strong>

 STRING ::= <strong>[a-zA-Z0-9_]</strong> <small>[REX]</small>

</pre>
</td>
</tr>
</table>

<p>

<p>This is just a formal way of describing the language, but don't
worry if you don't understand it very well because just below these lines we'll
try to describe it in a more informal way.</p>

<p>To begin with, you should know that EL is a language designed to
work with strings (a string is a collection of characters) but it has also some
logic and comparison operations. One important thing you have to be aware of is
that in EL blank spaces, tabulators or carriage returns have no more meaning
than separator for elements of the language; that means that between two basic
elements you can have as many spaces or carriage returns as you want.</p>

<p>One of the basic elements of the language is what we call <em>LITERALS</em>.
These things represent constant string values; they are delimited by a pair of
double quote (") symbols surrounding the string you want to express. Everything
you put inside the double quotes will be considered as it is, so inside a
literal several spaces or carriage have meaning (it's the only case). If you
want to express a double quote symbol inside a literal you have to <em>escape</em>
it using \.</p>

<p>Some examples of literals:</p>

<ul>
<li>If you want to represent the string <em>hello</em>,
inside the EL you'll have to use <code>"hello"</code>.</li>

<li>For the string <em>hello "big"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; man</em>, the representation in EL is <code>"hello \"big\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; man"</code>
(notice the escape characters and that spaces have meaning).</li>

<li><em>Let's see \""</em> string has to be expressed in this
way <code>"Let's see \\\"\""</code>.</li>
</ul>

<p>Another important basic element of the language is <em>VARIABLES</em>.
These elements represent string data from the input to which you can refer
inside of the language (and is considered also as a string). Variables are defined
in advance by the administrator (or even users) so you have to know which of
them you have access to. Additionally, variables can contain <em>FIELDS</em> that
are simply other input values that are grouped under a variable because they
have some kind of relationship between them (for example, you could have a
variable for the information about the author and fields like name, born place,
etc for it). If you want to know more about variables and their correspondence
with the input you can look at the <em>Mapping the Input</em> section. The way of
expressing a variable in EL is by a dollar symbol followed by any letter,
number or underscore; variables are case-insensitive. To refer to any field of
a variable, you simply put a dot followed by the field name (which is also made
up of any character, number or underscore).</p>

<p>Some examples about variables and fields:</p>

<ul>
<li>Imagine you have a variable which contains the author
information and which is called <em>author</em>, to represent in EL you would
have to write <code>"Author: " $100.a</code>. In every place
that $author appears BibFormat will consider the value defined for it from the
current input record.</li>

<li>Then you know that the field <em>name</em> of variable <em>author</em>
contains the author full name and you want to refer to it inside an EL
statement, so you'd write <code>$author.name</code>.</li>

<li>If we speak about CDS configuration, variable and field
names correspond to MARC 21 tag &amp; indicator names; so to refer to the main
title of a bibliographic record we should use variable <em>245</em> field <em>b</em>,
in EL terms: <code>$245.b</code>.</li>
</ul>

<p>Now that we know basic elements of the language we can start
thinking about how to combine them. The most important (and unique) string
operation is concatenation: adding strings. This operation is implicit to the
language, so we just put language elements one before another, and the representation
result will be the result of the basic elements one after another.</p>

<p>Some samples:</p>

<ul>
<li>To represent the constant string <em>Author:</em>
followed by the name of the author of the input record you should write <code>"Author: " $100.a</code> (it's supposed CDS
configuration in which MARC 21 notation is used; authors correspond to variable
100 field a).</li>

<li>You want to output the title in bold (always HTML
speaking) followed by the author in normal chars separated of the title by char
/: <code>"&lt;b&gt;" $245.b "&lt;/b&gt;/" $100.a</code></li>
</ul>

<p>These two, literals and variables, are only basic elements of
the EL. You can combine them using concatenation to get new strings. But, of
course, there are some more operations you can apply over strings: UDFs (<em>User
Defined Functions</em>). We'll also name these elements as functions, because
they are that: functions or operations to be applied over strings; when talking
about strings we include basic elements or resulting string from applying any
operations. A UDF has a name that identifies it uniquely and needs to get some information
that we call <em>parameters</em>. A UDF gives another string as result depending
on the parameter values (always strings). So to represent a function in EL you
need its name followed by an open parenthesis, the parameter values separated
by comas and a closing parenthesis. There's a list of UDF you can look at
through the interface but this list can be extended to fit your needs (look at <em>UDFs</em>
section of this manual).</p>

<p>Some examples:</p>

<ul>
<li>You want to ensure that the title of a bibliographic
record is always going to be in capital letters; good, there's a function
called <em>upper</em> that takes one parameter and gives as result the parameter
transformed in capital letters. You have to write the call like this: <code>upper($245.b)</code>.</li>

<li>You want only the 3 first chars of an author name to
appear in capital letters. We've seen there's a function for uppercasing a
string but there's another one, called <em>copy</em> that gets a sub string from
a string passed as first parameter from the char position indicated by the 2<sup>nd</sup>
parameter and with the length given by the 3<sup>rd</sup> one: <code>copy(
upper($100.a), "0", "3")</code>.</li>
</ul>

<p>As you can see, these UDFs are very powerful because you can
concatenate their result with another element (literal, variable or even
function) and the parameters can be basic elements or expressions. We can
extend this ensuring that any element or expression of the EL that gives as
result a string value can be combined with other EL expressions or elements.</p>

<p>Another very useful feature of EL is the possibility to use <em>KWONLEDGE
BASES</em> (KBs). A KB is just a set of key values that map (one-to-one) another
set of values; may be knowledge bases isn't a very appropriate name because
they are more like translation tables. BibFormat offers tools to create and
maintain KBs that can be used in the EL afterwards (see chapter <em>KBs
management</em> in this manual). You can see KB invocation as a special function
(the syntax for calling it is the same) with name <em>kb</em> and that takes two
parameters: one for indicating the KB name (BibFormat can handle several KBs)
and another one for the key value to translate. The result is the mapped KB
value or an empty string if it doesn't exist as a key value in the specified
KB. A typical example is when you have months with numbers and you want to
translate them into month names; you could have a KB that maps all the month
numbers to month names and then call it like this <code>kb("MONTH", $m)</code>.</p>

<p>Now let's move to <em>FORMATS</em>. Formats are some <em>EL</em>
code which is grouped under a label (a name) and that can be used in any other
EL statement. BibFormat allows the user to define as many formats as he wants
and identify each of them with a simple name. In few words, formats allow you
to reuse EL code; within a format you can put any EL code (even other format
calls) and all the variable values are completely available. Again, a format call in EL follows the same
convention as functions: the word <em>format</em> followed by the format name (a
string) between parenthesis. When you call a format is like if the EL code
define inside that format was pasted, as it is in the place you make the call.</p>

<p>Example: Imagine you have to write the title of a bibliographic
records with a certain format, let's say in bold and red; but this formatted
title you are going to use it in several places. So can take advantages of EL
formats and define a format called <em>TITLE</em> that contains the code <code>"&lt;font color=\"red\"&gt;&lt;b&gt;" $245.b
"&lt;/b&gt;&lt;/font&gt;"</code>. Once this is done, you could use it to format
records by printing their title in that way and their author after it:
<code>format("TITLE") "/" $100.a</code>. The good thing
is that if some day you decide to change the title formatting you'd only need
to modify the <em>TITLE</em> format definition and not all the places where you
show the title.</p>

<p>At this point, you have seen basic elements and operations with
EL. You may think that is powerful enough to express your formatting work, but
there are more complex situations that you'll have to face. We have tried to
design the EL to be easy enough but with the next advanced structures,
sometimes, can arrive to be a bit complex.</p>

<p>All these basic elements and operations are quite OK. But there
are sometimes where you want to compare expressions and decide what to do
depending on the result of the comparison. For this purpose, EL has an IF
statement and a few comparison and logic operators built in (don't forget that
any functionality needed can be achieved by defining new UDFs; EL gives basic
operations to provide this possibility). Let's go step by step: First let's
talk about the set of operators that can be used in a comparison:</p>

<ol>
<li>Comparison operators: Equal and non-equal (=, !=). They take
two operators that have to be strings and produce a logic (true or false)
value.</li>

<li>Logical operators: AND, OR and NOT (&amp;&amp;, ||, !). All of
them have to be used over logical values, taking two operators AND and OR, and
one operator NOT.</li>
</ol>

<p>All of them are right associative (except NOT which is unary
left-associative) and their precedence goes like this (more to less): NOT,
(EQUAL, NON-EQUAL), (AND, OR). These operators cannot be used anywhere, only
inside statements that expect a logic value as result, in other words, inside
condition statements.</p>

<p>The IF structure is quite easy to learn: First we indicate the
word <em>IF</em> followed by a condition statement surrounded by parenthesis;
then a EL statement into braces can be specified, this statement will be
executed only if the condition was true; optionally, we can add an <em>ELSE</em>
word followed by another EL statement into braces, that will only be triggered
if the IF condition was not true.</p>

<p>Let's have a look at some examples:</p>

<ul>
<li>I want the title of a record to appear followed by the
constant <em>Author:</em> and its author afterwards. But it could be nice if the
constant string appeared only if the record has author:
<pre>
format("TITLE") if($100.a!="") { "Author: " $100.a }
</pre>
</ul>

<p>BibFormat is not only an EL processor. Among others, it contains
a link solver that contains it's own rule repository in order to be able to
automatically solve links (see chapter Link solver of this manual). EL has one
special structure for asking the link solver for some links and including them
in the formatted version of the bibliographic record. This way links are easy
to maintain (you modify the rules independently from where the link is being
used) and as re-usable as formats or UDFs. Links are identified by a label and
need some information to be passed as parameters; then an EL statement has to
be specified which will be effective only if the link is solved and inside
which, you'll have access to an special variable, named <em>LINK</em>, which
contains the solved link among other information (see chapter Link solver for
more information about which values are accessible); additionally, an else
statement can be added (following the same syntax as in the IF construction)
that will be effective only if the link can't be solved by the Link solver.</p>

<p>Example:</p>

<ul>
<li>We are with our typical example of the simple format
that contains the title and the author, but now we want the author to be linked
to the search. Supposing that a this kind of link is already defined under the
label "AUTHOR_SEARCH" we should proceed like this:
<pre>
format("TITLE") "/"
link("AUTHOR_SEARCH", $100.a)
    { "&lt;a href=\""$link "\"&gt;"$100.a"&lt;/a&gt;"}
</pre>
</li>
</ul>

<p>The next step when talking about EL components is to deal with
multiple values. Life is no so easy and, of course, and a bibliographic record
can have more than one author or can have a related document which is in more
than one format and that has to be linked. In other words, BibFormat supports
having variables and fields with multiple values (see chapter <em>Mapping input</em>),
consequently a way of applying an EL statement over all the values of a
variable or a field would be quite useful. <em>FORALL</em> is our construction!!
It allows you to specify a variable or a field followed by a EL statement
(between braces) that will be applied for every value of the variable or the
field; any reference to the iteration variable inside the <em>FORALL</em> EL
statement will be related to the current iteration variable value (if you refer
to a variable that has multiple values outside a <em>FORALL</em> the first value
is considered). One limitation is that you shouldn't nest <em>FORALL</em>
statements, in other words, never put a <em>FORALL</em> inside another one. This
construction let's you also limit the number of times you want to iterate over
a variable or field by adding a literal with the number of iterations.</p>

<p>Some examples:</p>

<ul>
<li>Let's continue refining our simple format; now we have
to consider that there can be more than one author for one bibliographic
record, so we want to show all of them with the link included, of course.
<pre>

format("TITLE") "/"
forall($100.a)
{
  link("AUTHOR_SEARCH", $100.a)
    { "&lt;a href=\""$link "\"&gt;"$100.a"&lt;/a&gt;"}
}
</pre>
</li>

<li>Although this <em>FORALL</em> construction could seem not
very useful, it's used a lot when defining formats or behaviors. Quite often
you will have the case where you want only some EL piece of code to be
effective if a certain variable or field exist; <em>FORALL</em> can also be used
in that situation and it has to be said that is the most comfortable way of
doing it. Imagine the case you want the title, the constant string "Author: "
followed by the authors of a bibliographic record; but you don't want the
constant <em>"</em>Author: " to appear if there's no author at all. You could use
something like this:
<pre>

format("TITLE") " - "
forall($100.a)
{
  rep_prefix("Author: ") $100.a " "
}
</pre>

As you can see we are
using a new function: <em>rep_prefix</em>. In fact this is an UDF which prints
the string passed as parameter only once at the beginning inside a <em>FORALL</em>
statement. But the interesting thing here is the <em>FORALL</em> application.</li>
</ul>

<p>Finally, there's still one EL special function: <em>COUNT</em>.
Due to certain special situations or strange input data in the variables,
sometimes is useful to know how many values contain a variable or a field. So
this function, simply takes a variable or field as argument and returns a
string with the number of values that contains; if the value returned is 0,
that means that no value is in the variable, what means that variable doesn't
exist or there weren't any values mapped from the input.</p>

<p>Examples:</p>

<ul>
<li>As this is the last example, let's do it a bit more
complicated: Continuing with our very well known simple format, we want all the
authors of the record appear if there are less than 10, in any other case we
want only the first one to appear followed by the string "et al.". We'll also
use a function called <em>GT</em> which returns a non-empty string if the first
parameter is greater than the second one.
<pre>

format("TITLE") "/" 
if(gt(count($100.a), "10")!="")
{ $100.a "et al." }
else
{
  forall($100.a)
  {
    link("AUTHOR_SEARCH", $100.a) 
     { "&lt;a href=\""$link "\"&gt;"$100.a"&lt;/a&gt;"}
  }
}
</pre>
</li>
</ul>


<define-tag FIXME-NEW-GUIDE>
## $Id$
## This file is part of the CERN Document Server Software (CDSware).
## Copyright (C) 2002, 2003, 2004, 2005 CERN.
##
## The CDSware is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## The CDSware is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with CDSware; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

#include "cdspage.wml" \
    title="BibFormat Admin Guide" \
    navtrail_previous_links="<a class=navtrail href=<WEBURL>/admin/<lang:star: index.*.html>><MSG_ADMIN_AREA></a> &gt; <a class=navtrail href=<WEBURL>/admin/bibformat/>BibFormat Admin</a>" \
    navbar_name="admin" \
    navbar_select="bibformat-guide-new"

<h2>Contents</h2>
<ol>
<li><a href="#shortIntro">A Five minutes Introduction to BibFormat</a>
     <ol>
     <li><a href="#philosophy">How BibFormat works</a></li>
     <li><a href="#tutorial">Short Tutorial</a></li>
     <li><a href="#administerWebFile">Administer Through the Web Interface or Through the Configuration files</a></li>
    </ol>
</li>
<li><a href="#outputFormats">Output Formats</a>
    <ol>
    <li><a href="#addOutputFormat">Add an Output Format</a></li>
    <li><a href="#removeOutputFormat">Remove an Output Format</a></li>
    <li><a href="#rulesOutputFormat">Edit the Rules of an Output Format</a></li>
    <li><a href="#attrsOutputFormat">Edit the Attributes of an Output Format</a></li>
    <li><a href="#dependenciesOutputFormat">Check the Dependencies an Output Format</a></li>
    <li><a href="#validityOutputFormat">Check the Validity an Output Format</a></li>
    </ol>
</li>
<li><a href="#formatTemplates">Format Templates</a>
    <ol>
    <li><a href="#addFormatTemplate">Add a Format Template</a></li>
    <li><a href="#removeFormatTemplate">Remove a Format Template</a></li>
    <li><a href="#codeFormatTemplate">Edit the Code of a Format Template</a>
    <ol>
    <li><a href="#editFormatTemplate">Basic Editing</a></li>
    <li><a href="#elementsInFormatTemplate">Use Format Elements</a></li>
    <li><a href="#previewFormatTemplate">Preview a Format Template</a></li>
    <li><a href="#internationalizationTemplate">Internationalization (i18n)</a></li>
    </ol>
    </li>
    <li><a href="#attrsFormatTemplate">Edit the Attributes of a Format Template</a></li>
    <li><a href="#dependenciesFormatTemplate">Check the Dependencies of a Format Template</a></li>
    <li><a href="#validityFormatTemplate">Check the Validity a Format Template</a></li>
    </ol>
</li>
<li><a href="#FormatElements">Format Elements</a>
    <ol>
    <li><a href="#addFormatElement">Add a Format Element</a></li>
    <li><a href="#removeFormatElement">Remove a Format Element</a></li>
    <li><a href="#codeFormatElement">Edit the Code of a Format Element</a></li>
    <li><a href="#previewFormatElement">Preview a Format Element</a></li>
    <li><a href="#internationalizationFormatElement">Internationalization (i18n)</a></li>
    <li><a href="#attrsFormatElement">Edit the Attributes of a Format Element</a></li>
    <li><a href="#dependenciesFormatElement">Check the Dependencies of a Format Element</a></li>
    <li><a href="#validityFormatElement">Check the Validity of a Format Element</a></li>
    <li><a href="#browseDocFormatElement">Browse the Format Elements Documentation</a></li>

    </ol>
</li>
<li><a href="#KBs">Knowledge Bases</a>
    <ol>
    <li><a href="#addKB">Add a Knowledge Base</a></li>
    <li><a href="#removeKB">Remove a Knowledge Base</a></li>
    <li><a href="#addMappingKB">Add a Mapping</a></li>
    <li><a href="#removeMappingKB">Remove a Mapping</a></li>
    <li><a href="#editMappingKB">Edit a Mapping</a></li>
    <li><a href="#attrsKB">Edit the Attributes of a Knowledge Base</a></li>
    <li><a href="#validityKB">Check the Dependencies a Knowledge Base</a></li>
    </ol>
</li>
<li><a href="#marcNotation">MARC Notation in Formats</a></li>
<li><a href="#migration">Migrating from Previous BibFormat</a></li>   
<li><a href="#faq">FAQ</a></li>
</ol>

<style type="text/css">
<!--
.outputFormatBox {
	font-weight: bold;
	color: #990000;
	background-color: #F4CBCC;
	border: 2px dotted #FF0000;
}
.outputFormatBoxMain {
	font-weight: bold;
	color: #990000;
	background-color: #F4CBCC;
	border: 1px solid #FF0000;
	padding: 4px;
}
.formatTemplateBox {
	font-weight: bold;
	color: #003300;
	background-color: #DEFDBB;
	border: 2px dotted #009900;
}
.formatTemplateBoxMain {
	font-weight: bold;
	color: #003300;
	background-color: #DEFDBB;
	border: 1px solid #009900;
	padding: 5px;
}
.formatElementBox {
	font-weight: bold;
	color: #000066;
	background-color: #CCFFFF;
	border: 2px dotted #0066CC;
}
.formatElementBoxMain {
	font-weight: bold;
	color: #000066;
	background-color: #CCFFFF;
	border: 1px solid #0066CC;
	padding: 5px;
}
-->
</style>


<h2><a name="shortIntro">A Five Minutes Introduction to BibFormat</a></h2>
<h3><a name="philosophy">How BibFormat Works</a></h3>
<p>BibFormat is in charge of formatting the bibliographic records that
are displayed to your users. It is called by the search engine when it has to
format a record.</p>

<p>As you  might need different kind of formatting depending
on the type of record, but potentially have a huge amount of records in your database, you cannot specify
for each of them how they should look. Instead BibFormat uses a rule-based decision process
to decide how to format a record.<br/>
The best way to understand how BibFormat works is to have a look at
a typical workflow:</p>

<table width="90%" border="0" cellspacing="5" cellpadding="0">

  <tr>
  <td colspan="2"><span style="white-space: nowrap;">Step 1:</span></td>
  </tr>
  <tr valign="top">
    <td>
    <img src="guide_url_bar.png" alt="http://cdsweb.cern.ch/search.py?recid=946417&amp;ln=en&amp;of=hd"/>
    </td>
    
    <td width="50%">When CDS Invenio has to display a record, it
      asks BibFormat to format the record with the given output format
      and language. For example here the requested output format is
      <span class="outputFormatBox">hd</span>, which is a short code
      for &quot;HTML Detailed&quot;. This means that somehow a user arrived on
      the page of the record and asked for a detailed view of the
      record.</td>
      
  </tr>

  <tr>
  <td colspan="2"><hr/><span style="white-space: nowrap;">Step 2:</span></td>
  </tr><tr valign="top">
  <td><img src="guide_output_format_hd_rules.png" alt="1. Use Template [Picture HTML Detailed] if tag [980.a] is equal to [PICTURE] 2. Use Template [Thesis HTML detailed] if tag [980.a] is equal to [THESIS] 3. By default use [Default HTML Detailed]"/>

    <td>
    Beside is a screenshot of the "hd" or "HTML Detailed" output format.
    You can see that the output format does not specify how to format the record, but
    contains a set of rules which define which template must be used.<br/>
    The rules are evaluated from top to bottom.
    Each rule defines a condition on a field of the record, and a format template to use to
    format the record if the condition matches.
    Let's say that the field 980.a of the record is equal to
    &quot;Picture&quot;. Then first rules matches, and format template
    <span class="formatTemplateBox">Picture HTML Detailed</span> is
    used for formatting by BibFormat.<br/>
    You can add, remove or edit output formats <a href="bibformatadmin.py/output_formats_manage">here</a></td>
    </tr>
  
  <tr>
  <td colspan="2"><hr/><span style="white-space: nowrap;">Step 3:</span></td>
  </tr>
    <tr valign="top"> 
    <td> 
      <div class="formatTemplateBoxMain"><code>
        &lt;h1 align=&quot;center&quot;&gt;&lt;BFE_MAIN_TITLE/&gt;&lt;/h1&gt;<br />
        &lt;p align=&quot;center&quot;&gt;<br />
        <span class="formatElementBox">&lt;BFE_AUTHORS separator=&quot;; &quot; 
        link=&quot;yes&quot;/&gt;</span>&lt;br/&gt;<br />
        &lt;BFE_DATE format=&quot;%d %B %Y&quot;&gt; .- &lt;BFE_NB_PAGES suffix=&quot;p&quot;&gt;<br />
        &lt;/p&gt;</code></div></td>
        
    <td>We see an extract of the Picture HTML Detailed format on the right,
    as it is shown in the template editor.  As you can see it
    is mainly written using HTML. There are however some tags that
    are not part of standard HTML. Those tags that starts with
    <em>&lt;BFE_</em> are placeholders for the record values. For
    example &lt;BFE_MAIN_TITLE/&gt; tells Bibformat to write the title
    of the record. We call these tags &quot;elements&quot;. Some
    elements have parameters. This is the case of the <span
    class="formatElementBox">&lt;BFE_AUTHORS&gt; </span> element,
    which can take <em>separator</em> and <em>link</em> as
    parameters. The value of separator will be used to separate
    authors' names and the link parameter tells if links to authors'
    websites have to be created. 
    All elements are described in the <a href="bibformatadmin.py/format_elements_doc">elements documentation</a>.<br/>
    You can add, remove or edit format templates <a href="bibformatadmin.py/format_templates_manage">here</a></td>
      
  </tr>
  <tr><td colspan="2"><hr/><span style="white-space: nowrap;">Step 4:</span></td></tr>
  <tr valign="top">
    <td><div class="formatElementBoxMain">
    <code>def format(bfo, separator='; ', link='no'):<br />
      &nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br />
      &nbsp;&nbsp;&nbsp;Prints the list of authors for the record<br /><br />
      &nbsp;&nbsp;&nbsp;@param separator a character to separate the authors<br />
      &nbsp;&nbsp;&nbsp;@param link if 'yes' print HTML links to authors<br />
      &nbsp;&nbsp;&nbsp;&quot;&quot;&quot;<br />
      &nbsp;&nbsp;&nbsp;authors = bfo.fields(&quot;100__a&quot;)<br />
      &nbsp;&nbsp;&nbsp;if link == 'yes':<br />
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;authors = map(lambda x: '&lt;a href="'+weburl+'/search.py?f=author&p='\<br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                                                        + quote(x) +'"&gt;'+x+'&lt;/a&gt;', authors)<br />
      &nbsp;&nbsp;&nbsp;return authors.split(separator)</code> 
      </div></td>

    <td>A format element is written in Python. It acts as a bridge
    between the record in the database and the format
    template. Typically you will not have to write or read format
    elements, juste call them from the templates. Each element outputs
    some text that is written in the template where it is called.<br/>
    Developers can add new elements by creating a new file, naming it
    with the name of element, and write a Python <code>format</code>
    function that takes as parameters the parameters of the elements
    plus a special one <code>bfo</code>. Regular Python code can be
    used, including import of other modules.</td>

  </tr>
</table>
<br />

<p>In summary BibFormat is called by specifying a record and an output
format, which relies on different templates to do the formatting, and
which themselves rely on different format elements. Only developers need to modify
the format elements layer.<p>


<table width="50%" border="0" align="center" cellpadding="0" cellspacing="2">
  <tr align="center"> 
    <td colspan="4"><div class="outputFormatBoxMain">Output Format</div></td>
  </tr>
  <tr align="center"> 
    <td colspan="2"><div class="formatTemplateBoxMain">Template</div></td>
    <td colspan="2"><div class="formatTemplateBoxMain">Template</div></td>
  </tr>
  <tr align="center"> 
    <td><div class="formatElementBoxMain">Format Element</div></td>
    <td><div class="formatElementBoxMain">Format Element</div></td>
    <td><div class="formatElementBoxMain">Format Element</div></td>
    <td><div class="formatElementBoxMain">Format Element</div></td>
  </tr>
</table>
<p>You should now understand the philosophy behind BibFormat. </p>

<h3><a name="tutorial">Short Tutorial</a></h3>
<p> Let's try to create our own format.
This format will just print the title of a record.
</p>

<p>First go to the main <a href="bibformatadmin.py">BibFormat admin page</a>.
Then click on the "Manage Ouput Format" links. You will see the list of all output formats:</p>
<img src="guide_output_formats_manage_tutorial.png" alt="Output formats management page"/>
<p>This is were you can delete, create or check output formats.
The menu at the top of the page let you go to other admininistration pages.<br/>
Click on the "Add New Output Format" button at the bottom of the page. You can then fill in some attributes
for the output format. Choose "title" as code, "Only Title" as name and "Prints only title" as description:</p>
<img src="guide_output_format_update_attributes_tutorial.png" alt="Screenshot of the Update Output Format Attributes page" />
<p>Leave other fields blank, and click on the button "Update Output format Attributes".<br/> You are then
redirected to the rules editor. Notice the menu at the top which let you close the editor, change the attributes again
and check the output format. However do not click on these links before saving your modification of rules!</p>
<img src="guide_rules_editor_tutorial.png" alt="Output format menu" />
<p>As our format does not need to have a different behaviour depending on the record, we do not need to add new rules to the format. You just need to select a format template in the "By default use" list. However we first have to create our special format template that only print titles. So close the editor using the menu at the top of the page, and in the menu that just appeared instead, click on "Manage Format Templates". In a similar way to output formats, you see the list of format templates.</p>
<img src="guide_templates_manage_tutorial.png" alt="Format template management page" />
<p>
Click on the "Add New Format Template" button at the bottom of the page. As for the output format, fill in the attributes of the template with name "Title" and any relevant description.
</p>

<img src="guide_template_attributes_tutorial.png" alt="update format template attributes"/>
<p>Click on the "Update Output Format Attributes" button. You are redirected to the template editor. The editor is divided in three parts. The upper left part contains the code of the template. The bottom part is a preview of the template. The part on the right side is a short remainder of the format elements you can use in you template. You can hide this documentation by clicking on  "Hide Documentation".</p>
<img src="guide_template_editor_tutorial.png" alt="Format template editor" />
<p>The above screenshot shows the template code already filled in. It calls the <code>BFE_TITLE</code> element. If you do not know the name of the element you want to call, you can search for it using the embedded documentation search. You can try to add other elements into your template, or write some HTML formatting.</p>
<p>When you are satisfied with your template, click on the save button, close the editor and go back to the "Only titles" output format rules editor. There select the template you have just created in the "Use by default" menu and save the ouput format and you are done. </p>
<p>This tutorial does not cover all aspects of the management of formats (For example "Knowledge bases" or internationalization). It also does not show all the power of output formats, as the one we have created simply call a template. However you have seen enough to configure BibFormat trough the web interface. Read the sections below to learn more about it.</p>

<h3><a name="administerWebFile">Administer Through the Web Interface or Through the Configuration files</a></h3>
<p>BibFormat can be administered in two ways. The first way is to use the provided web interface. It should be the most
convenient way of doing for most users. The web interface is simple to use and provides great tools to manage your formats. Its only limitation concerns the format elements, which cannot be modified using it (But the web interface provide a dynamically generated documentation of your elements). <br/>
The other way to administer BibFormat is to directly modify the configuration files using your preferred text editor. This way of doing can bring much power to power users, but requires an access to the server's files. It also requires that the user double-check his modifications, or use the web interface to ensure the validity and correctness of his formats.</p>
<p>In this manual we will show both ways of doing. For each explication we show first how to do it through the web interface, then how to do it by manipulating the configuration files. Non-power users can stop reading as soon as they encounter the text "For developers and adventurers only".</p>
<p>We generally recommend to use the web interface, excepted for writing
format elements.</p>


<h2><a name="outputFormats">Output Formats</a></h2>
   <p>As you potentially have a huge amount of
bibliographic records, you cannot specify manually for each of them
how it should be formatted. This is why you can define rules that will
allow BibFormat to understand which kind of formatting to apply to a given
record. You define this set of rules in what is called an "output
format".</p>

<p>You can have different output formats, each with its own characteristics.
For example you certainly want that when multiple bibliographic records are
displayed at the same time (as it happens in search results), only
short versions are shown to the user , while a detailed record is
preferable when a single record is displayed, whatever the type of the record.<br/>
You might also want to
let your users decide which kind of output they want. For example you
might need to display HTML for regular web browsing, but would also
give a BibTeX version of the bibliographic reference for direct
inclusion in a LaTeX document.</p>
<p>To summarize, an output format groups similar kind of formats, specifying which kind
of formatting has to be done, but not how it has to be done.</p>

    <h3><a name="addOutputFormat">Add an Output Format</a></h3>
    <p>To add a new output format, go to the <a href="bibformatadmin.py/output_formats_manage">Manage Output Formats</a> page and click on the "Add New Output Format" button at the bottom of the page. The format has been created. You can then specify the attributes of the output format. See <a href="#attrsOutputFormat">Edit the Attributes of an Output Format</a> to learn more about it.<p>
    <strong>For developers and adventurers only:</strong>
    <p>Alternatively you can directly add a new output format file into the
  /etc/bibformat/outputs/ directory of your CDS Invenio installation, if you have
  access to the server's files. Use the format extension .bfo for your file.</p>
  <p>You should also check that user <code>www-data</code> has read/write access to the file,
  if you want to be able to modify the rules through the web interface.</p>

<h3><a name="removeOutputFormat">Remove an Output Format</a></h3>
<p>To remove an output format, go to the <a href="bibformatadmin.py/output_formats_manage">Manage Output Formats</a> page and click on the "Delete" button facing the output format you want to delete. If you cannot click on the button (the button is not enabled), this means that you do not have sufficent priviledge to do so (Format is protected. Contact the administrator of the system).</p>
<strong>For developers and adventurers only:</strong>
<p>You can directly remove an output format from the /etc/bibformat/outputs/ directory of your CDS Invenio installation.
However you must make sure that it is removed from the tables <code>format</code> and <code>formatname</code> in the database, so that other modules know that it is not longer available.</p>

<h3><a name="rulesOutputFormat">Edit the Rules of an Output Format</a></h3>
    <p>When you create a new output format, you can at first only specify the default template,
    that is the one which is used when all rules fail. In the case of a basic output format,
    this is enough. You can however add other rules, by clicking on the "Add New Rule" button.<br/>
    Once you have added a rule, you can fill it with a condition, and a template that should be used
    if the condition is true. For example the rule</p>
    <img src="guide_output_format_edit_rule.png" alt="Rule: Use template [Picture HTML Detailed] if field [980.a] is equal to [PICTURE]"/>
   <p> will use template named "Picture HTML Detailed" if the field <code>980.a</code> of the record to format is equal to "Picture".
    Note that text "PICTURE" will match any letter case like "picture" or "Picture".
    Leading and trailing spaces are ignored too ("  Picture  " will match "PICTURE").
    <br/><b>Tips:</b> you can use a regular expression as text. For example "PICT.*" will match "pictures"
    and "PICTURE".</p>
    
    <p><div style="float:right"><img src="guide_output_format_edit_rule2.png" alt="Reorder rules using arrows"/></div>
    The above configuration will use format template "Default HTML Detailed" if all above rules fail (in that case
    if field 980.a is different from "PICTURE"). If you have more rules, you decide in which order the conditions are evaluated. You can reorder rules by clicking on the small arrows on the left of the rules.
    
    </p>
    <strong>For developers and adventurers only:</strong>
    <p>To write an output format, use the following syntax:<br/>
    First you
    define which field code you put as the conditon for the rule.
    You suffix it with a column. Then on next lines, define the values of
    the condition, followed by --- and then the filename of the template
    to use:</p>
<pre>
  tag 980.a:
  PICTURE --- PICTURE_HTML_BRIEF.bft
  PREPRINT --- PREPRINT_HTML_BRIEF.bft
  PUBLICATION --- PUBLICATION_HTML_BRIEF.bft
</pre>
    <p>
    This means that if value of field 980.a is equal to PICTURE, then we
    will use format template PICTURE_HTML_BRIEF.bft. Note that you must
    use the filename of the template, not the name. Also note that spaces
    at the end or beginning are not considered. On the following lines,
    you can either put other conditions on tag 980.a, or add another tag on
    which you want to put conditions.</p>
    <p>At the end you can add a default condition:</p>
<pre>
   default: PREPRINT_HTML_BRIEF.bft
</pre>
    <p>which means that if no condition is matched, a format suitable for
    Preprints will be used to format the current record.<p>

    <p>The output format file could then look like this:</p>
<pre>
  tag 980.a:
  PICTURE --- PICTURE_HTML_BRIEF.bft
  PREPRINT --- PREPRINT_HTML_BRIEF.bft
  PUBLICATION --- PUBLICATION_HTML_BRIEF.bft

  tag 8560.f:
  .*@cern.ch --- SPECIAL_MEMBER_FORMATTING.bft

  default: PREPRINT_HTML_BRIEF.bft
</pre>
    <p> You can add as many rules as you want. Keep in mind that they are read
    in the order they are defined, and that only first rule that
    matches will be used.
    Notice the condition on tag 8560.f: it uses a regular expression to
    match any email address that ends with @cern.ch (the regular
    expression must be understandable by Python)
    </p>
    <h3><a name="attrsOutputFormat">Edit the Attributes of an Output Format</a></h3>
    <p>An output format has the following attributes:
    <ul>
    <li><code>code</code>: a short identifier that is used to identify the output format. It must be unique and contain a maximum of 6 letters. The short identifier ignores letter case ("HB" is equal to "hb").</li>
    <li><code>content type</code>: this is the content type of the format, specified in Mime. For example if you were to produce an Excel output, you could use <code>application/ms-excel</code> as content type. If a content type is specified, CDS Invenio will not print the usual header and footerfor the page, but will trigger a download in the client's browser when viewing the page (Unless the browser handles this content type).</li>
    <li><code>name</code>: a generic name to display in the interface for this output format.</li>
    <li>(*) <code>name</code>: internationalized names for the output format, used for displaying localized name in the search interface.</li>
    <li><code>description</code>: an optional description for the output format.</li>
    </ul></p>
    <strong>For developers and adventurers only:</strong>
    <p>Excepted for the code, output format attributes cannot be changed in the output format file. These
    attributes are saved in the database. As for the <code>code</code>, it is the name of the output format file,
    without its <code>.bfo</code> extension. If you change this name, do not forget to propagate the modification in the database.</p>
    <h3><a name="dependenciesOutputFormat">Check the Dependencies an Output Format</a></h3>
    <p>To check the dependencies of an output format on format templates, format elements and tags,
    go to the <a href="bibformatadmin.py/output_formats_manage">Manage Output Formats</a> page, click on
    the output format you want to check, and then in the menu click on "Check Dependencies".</p>
    <img src="guide_output_format_check_dependencies.png" alt="Check Dependencies menu"/>
    <p>The next page shows you:
    <ul> <li>the format templates which might be called by the rules of the output format</li>
    <li>the elements used in each of these templates</li>
    <li>the Marc tags involved in these elements</li>
    </ul>
    Note that some Marc tags might be omitted.</p>
    <h3><a name="validityOutputFormat">Check the Validity an Output Format</a></h3>
    <p>To check the validity of an output format, simply go to the <a href="bibformatadmin.py/output_formats_manage">Manage Output Formats</a> page, and look at the column 'status' for the output format you want to check. If message "Ok" is there,
    then no problem was found with the output format. If message 'Not Ok' is in the column, click on it to see
    the problems that have been found for the output format.</p>

<h2><a name="formatTemplates">Format Templates</a></h2>
    <p>A format template defines the how a record should be formatted. For example it specifies which fields of the record are to be displayed, in which order and with which visual attributes. Basically the format template is written in HTML, so that it is easy for anyone to edit it.</p>
    <h3><a name="addFormatTemplate">Add a Format Template</a></h3>
    <p>To add a new format template, go to the <a href="bibformatadmin.py/format_templates_manage">Manage Format Templates</a> page and click on the "Add New Format Template" button at the bottom of the page. The format has been created. You can then specify the attributes of the format template. See <a href="#attrsFormatTemplate">Edit the Attributes of a Format Template</a> to learn more about it.<p>
    <strong>For developers and adventurers only:</strong>
    <p>Alternatively you can directly add a new format template file into the
  /etc/bibformat/templates/ directory of your CDS Invenio installation, if you have
  access to the server's files. Use the format extension .bft for your file.</p>
  <p>You should also check that user <code>www-data</code> has read/write access to the file,
  if you want to be able to modify the code and the attributes of the template through the web interface.</p>

    <h3><a name="removeFormatTemplate">Remove a Format Template</a></h3>
    <p>To remove a format template, go to the <a href="bibformatadmin.py/format_templates_manage">Manage Format Templates</a> page and click on the "Delete" button facing the format template you want to delete. If you cannot click on the button (the button is not enabled), this means that you do not have sufficent priviledge to do so (Format is protected. Contact the administrator of the system).</p>
<strong>For developers and adventurers only:</strong>
<p>You can directly remove the format template from the /etc/bibformat/templates/ directory of your CDS Invenio installation.</p>
    <h3><a name="codeFormatTemplate">Edit the Code of a Format Template</a></h3>
    <p>You can change the formatting of records by modifying the code of a template.
    <p>To edit the code of a format template
    go to the <a href="bibformatadmin.py/format_templates_manage">Manage Format Templates</a> page. Click on
    the format template you want to edit to load the template editor.</p>
   
    <p>The format template editor contains three panels. The left upper panel is the code editor. This is were
    you write the code that specifies the formatting of a template. The right-most panel is a short documentation
    on the "bricks" you can use in your format template code. The panel at the bottom of the page allows you to preview the template. </p>
     <img src="guide_template_editor.png" alt="Template Editor Page"/>
    <p>The following sections explain how to write the code that specifies the formatting.</p>
    <h4><a name="editFormatTemplate">Basic Editing</a></h4>
    <p>The first thing you have to know before editing the code is that everything you write in the
    code editor is printed as such by BibFormat. Well almost everything (as you will discover later).</p>
    <p>For example if you write "My Text", then for every record the output will be "My Text". Now let's say
  you write "&lt;b&gt;My Text&lt;/b&gt;": the output will still be "&lt;b&gt;My Text&lt;/b&gt;", but as we display in a web browser, it will look like
  "<b>My Text</b>" (The browser interprets the text inside tags &lt;b&gt;&lt;/b&gt; as "bold". Also note that the look may depend on the CSS style of your page).</p>
  <p>Basically it means that you can write HTML to do the formatting. If you are not experienced with HTML you can use an HTML editor to create your layout, and the copy-paste the HTML code inside the template.</p>
  <p>Do not forget to save your work by clicking on the save button before you leave the editor!</p>
  <strong>For developers and adventurers only:</strong>
  <p>
  You can edit the code of a template using exactly the same syntax as in the web interface. The code of the template
  is in the template file located in the /etc/bibformat/templates/ directory of your CDS Invenio installation. You just
  have to take care of the attributes of the template, which are saved in the same file as the code. See <a href="#attrsFormatTemplate">Edit the Attributes of a Format Template</a> to learn more about it.
  </p>

    <h4><a name="elementsInFormatTemplate">Use Format Elements</a></h4>
    <p>To add a dynamic behaviour to your format templates, that is display for example a different title
    for each record or a different background color depending on the type of record, you can use the format elements.</p>
    <p>Format elements are the smart bricks you can copy-paste in your code to get the attributes of template
    that change depending on the record. A format element looks like a regular HTML tag. </p>
    <p>For example, to print
    the title of a record, you can write <code>&lt;BFE_TITLE /&gt;</code> in your template code where you want to diplay the title</p>
    <p>Format elements can take values as parameters. This allows to customize the behaviour of an element. For example you can write <code>&lt;BFE_TITLE prefix="Title: " /&gt;</code>, and BibFormat will take care of printing the title for you, with prefix "Title: ". The difference between <code>Title: &lt;BFE_TITLE /&gt;</code> and <code>&lt;BFE_TITLE prefix="Title: " /&gt;</code> is that the first option will always write "Title: " while the second one will only print "Title: " if there exist a title for the record in the database. Of course there are chances that there is always a title for each record, but this can be useful for less common fields.</p>
    <p>Some parameters are available for all elements. This is the case for the following ones:
        <ul>
         <li><code>prefix</code>: a prefix printed only if the record has a value for the element.</li>
         <li><code>suffix</code>: a suffix printed only if the record has a value for the element.</li>
         <li><code>default</code>: a default value printed if the record has no value for the element. In that case <code>prefix</code> and <code>suffix</code> are not printed.</li>
        </ul>
    </p>
    <p>Some parameters are specific to elements. To get information on all available format elements you can read the <a href="bibformatadmin.py/format_elements_doc">Format Elements Documentation</a>, which is generated dynamically for all existing elements. it will show you what the element do and what parameters it can take.</p>
    <p>While format elements looks like HTML tags, they differ in the followings ways from traditional ones:
        <ul>
        <li>A format element is a single tag: you cannot have <code>&lt;BFE_TITLE &gt;some text&lt;BFE_TITLE /&gt;</code> but only <code>&lt;BFE_TITLE /&gt;</code>.</li>
        <li>The values of the parameters accept any characters, including &lt; and &gt;. The only limitation is that you cannot use the type of quotes that delimit that value: you can have for example <code>&lt;BFE_TITLE someParam="a lot of single quotes ' ' ' ' "/&gt;</code> or <code>&lt;BFE_TITLE someParam='a lot of double quotes " " " '/&gt;</code>, but not <code>&lt;BFE_TITLE someParam="a lot of same quotes as delimiter " " " "/&gt;</code>.</li>
        <li>Format elements names always start with <code>BFE_</code>.</li>
        <li>Format element can expand on multiple lines.</li>
        </ul>
        </p>
        <p><b>Tips:</b> you can use the special element <code>&lt;BFE_FIELD tag="" /&gt;</code> to print the value
        of any field of a record in your templates. This practice is however not
        recommended because it would necessitate to revise all format
        templates if you did change the meaning of the MARC code schema.</p>
        
    <h4><a name="previewFormatTemplate">Preview a Format Template</a></h4>
    <p>To preview a format template go to the <a href="bibformatadmin.py/format_templates_manage">Manage Format Templates</a> page and click on the format template you want to preview to open the template editor. The editor contains a preview panel at the bottom of the page.</p>
    <img src="guide_template_preview.png" alt="Preview Panel"/>
    <p>Simply click on " Reload Preview" button to preview the template (you do not need to save the code before previewing).<br/>
    Use the "Language" menu to preview the template in a given language</p>
    <p>You can fill in the "Search Pattern" field to preview a specific record. The search pattern uses exactly the same
    syntax as the one used in the web interface. The only difference with the regular search engine is that only the first matching record is shown.</p>
     <strong>For developers and adventurers only:</strong>
     <p>If you do not want to use the web interface to edit the templates but still would like to get previews, you can open the preview frame of any format in a new window/tab. In this mode you get a preview of the template (if it is placed in the /etc/bibformat/templates/ directory of your CDS Invenio installation). The parameters of the preview are specified in the url: <ul>
     <li><code>bft</code>: the filename of the format template to preview</li>
     <li><code>ln</code>: the language to use for the preview</li>
     <li><code>pattern_for_preview</code>: the search pattern to use for the preview</li>
     </ul></p>
    <h4><a name="internationalizationTemplate">Internationalization (i18n)</a></h4>
    <p>You can add translations to your format templates. To do so enclose the text you want to localize
    with tags corresponding to the two letters of the language. For example if we want to localize "title", write <code>&lt;en&gt;Title&lt;/en&gt;</code>. Repeat this for each language in which you want to make "title" available: <code>&lt;en&gt;Title&lt;/en&gt;&lt;fr&gt;Titre&lt;/fr&gt;&lt;de&gt;Titel&lt;/de&gt;</code>.
    Finally enclose everything with <code>&lt;lang&gt; &lt;/lang&gt;</code> tags: <code>&lt;lang&gt;&lt;en&gt;Title&lt;/en&gt;&lt;fr&gt;Titre&lt;/fr&gt;&lt;de&gt;Titel&lt;/de&gt;&lt;/lang&gt;</code></p>
<p>For each &lt;lang&gt; group only the text in the user's language is displayed. If user's language is not
available in the &lt;lang&gt; group, your default CDS Invenio language is used.</p>

    <h3><a name="attrsFormatTemplate">Edit the Attributes of a Format Template</a></h4>
    <p>To edit the attributes of a format template
    go to the <a href="bibformatadmin.py/format_templates_manage">Manage Format Templates</a> page, click on
    the format template you want to edit, and then in the menu click on "Modify Template Attributes".</p>
    <p>
    A format template contains two attributes:
    <ul>
    <li><code>Name</code>: the name of the template</li>
    <li><code>Description</code>: a short description of the template</li>
    </ul>
    <p>Note that changing these parameters has no impact on the formatting. Their purpose in only to
    document the template.</p>
    <p>If the name you have chosen already exists for another template, you name will be suffixed with an integer so that the name is unique.</p>
    <p>You should also be aware that if you change the name of a format template, all output formats that were linking to this template will be changed to match the new name.</p>
     <strong>For developers and adventurers only:</strong>
     <p>You can change the attriutes of a template by editing its file in the /etc/bibformat/templates/ directory of your CDS Invenio installation.  The attributes must be enclosed with tags <code>&lt;name&gt; &lt;/name&gt;</code> and <code>&lt;description&gt; &lt;/description&gt;</code> and should ideally be placed at the beginning of the file.</p>
     <p>Also note that the admin web interface tries to keep the name of the template in sync with the filename of the template. If the name is changed through the web interface, the filename of the template is changed, and all output formats that use this template are updated. You have to do update output formats manually if you change the filename of the template without the web interface.</p>
     
    <h3><a name="dependenciesFormatTemplate">Check the Dependencies of a Format Template</a></h3>
     <p>To check the dependencies of a format template
    go to the <a href="bibformatadmin.py/format_template_manage">Manage Format Template</a> page, click on
    the format template you want to check, and then in the menu click on "Check Dependencies".</p>
    <img src="guide_output_format_check_dependencies.png" alt="Check Dependencies menu"/>
    <p>The next page shows you:
    <ul> <li>The output formats that use this format template</li>
    <li>the elements used in the template (and Marc tags use in these elements in parentheses)</li>
    <li>A summary of all the Marc tags involved in the elements of the template</li>
    </ul>
    Note that some Marc tags might be omitted.</p>
    <h3><a name="validityFormatTemplate">Check the Validity a Format Template</a></h3>
    <p>To check the validity of a format template, simply go to the <a href="bibformatadmin.py/format_templates_manage">Manage Format Templates</a> page, and look at the column 'status' for the format template you want to check. If message "Ok" is there,
    then no problem was found with the template. If message 'Not Ok' is in the column, click on it to see
    the problems that have been found for the template.</p>
    
<h2><a name="FormatElements">Format Elements</a></h2>
 <p>Format elements are the bricks used in format templates to provide dynamic content to the formatting process.
 Their purpose is to allow non computer literate persons to easily integrate data from the records in the database into their templates. </p>
 <p>Format elements are typically written in Python (there is an exception to that point which is dicussed in <a href="#addFormatElement">Add a Format Element</a>). This brings great flexibily and power to the formatting process. This however restricts the creation of format elements to developers.</p>
    
    <h3><a name="addFormatElement">Add a Format Element</a></h3>
    <p>The most typical way of adding a format element is to drop a <code>.py</code> file in the lib/python/invenio/bibformat_elements directory of your CDS Invenio installation. See <a href="#codeFormatElement">Edit the Code of a Format Element</a> to learn how to implement an element.</p>
    <p>The most simple way to add a format element is to add a en entry in the "<a href="<WEBURL>/admin/bibindex/bibindexadmin.py/field">Logical Fields</a>" management interface of the BibIndex module. When BibFormat cannot find the Python format element corresponding to a given name, it looks into this table for the name and prints the value of the field declared for this name. This lightweight way of doing is straightforward but does not allow complex handling of the data (it limits to printing the value of the field, or the values of the fields if multiple fields are declared under the same label).</p>
    <h3><a name="removeFormatElement">Remove a Format Element</a></h3>
    <p>To remove a Python format element simply remove the corresponding file from the lib/python/invenio/bibformat_elements directory of your CDS Invenio installation.</p>
    <p>To remove a format element declared in the "<a href="<WEBURL>/admin/bibindex/bibindexadmin.py/field">Logical Fields</a>" management interface of the BibIndex module simply remove the entry from the table.</p>
    <h3><a name="codeFormatElement">Edit the Code of a Format Element</a></h3>
    <p>This section only applies to Python format elements. Basic format elements declared in "<a href="<WEBURL>/admin/bibindex/bibindexadmin.py/field">Logical Fields</a>" have non configurable behaviour.</p>
    <p>A format element file is like any regular Python program. It has to implement a <code>format</code> function, which returns a <code>string</code> and takes at least <code>bfo</code> as first parameter (but can take as many others as needed).</p>
    <p>Here is for example the code of the "bfe_title.py" element:
<pre>
def format(bfo, separator=" "):
    """
    Prints the title of a record.

    @param separator separator between the different titles
    """
    titles = []
   
    title = bfo.field('245.a')
    title_remainder = bfo.field('245.b')

    titles.append( title + title_remainder )

    title = bfo.field('0248_a')
    if len(title) > 0:
        titles.append( title )

    title = bfo.field('246.a')
    if len(title) > 0:
        titles.append( title )

    title = bfo.field('246_1.a')
    if len(title) > 0:
        titles.append( title )

    return separator.join(titles)
</pre>
In format templates this element can be called like a function, using HTML syntax:<br/>
<code>&lt;BFE_TITLE separator="; "/&gt;</code><br/>
Notice that the call uses (almost) the filename of your element. To find out which element to use, BibFormat tries different filenames until the element is found: it tries to <ol>
    <li>ignore the letter case</li>
    <li>replace underscore with spaces</li>
    <li>remove the BFE_ from the name</li>
    </ol>
    This means that even if the filename of your element is "my element.py", BibFormat can resolve the call &lt;BFE_MY_ELEMENT /&gt; in a format template. This also means that you must take care no to have two format elements filenames that only differ in term of the above parameters.
        </p>
    <p>The <code>string</code> returned by the <code>format</code> function corresponds to the value that is printed instead of the format element name in the format template.</p>
    <p>The <code>bfo</code> object taken as parameter by <code>format</code> stands for BibFormatObject: it is an object that represents the context in which the formatting takes place. For example it allows to retrieve the value of a given field for the record that is being formatted, or the language of the user. We see the details of the BibFormatObject further below.</p>
    <p>The <code>format</code> function of an element can take other parameters, as well as default values for these parameters. The idea is that these parameters are accessible from the format template when calling the elements, and allow to parametrize the behaviour of the format element.</p>
    <p>It is very important to document your element: this allows to generate a documentation for the elements accessible to people writing format templates. It is the only way for them to know what your element do. The key points are:
        <ul>
        <li>Provide a docstring for the <code>format</code> function</li>
        <li>For each of the parameters of the <code>format</code> function (except for <code>bfo</code>), provide a description using a Java-like doc syntax in the doc string:<br/> <code>@param my_param description for my param</code> (one line per parameter)</li>
        <li>You can use one <code>@see</code> followed by a comma separated list of elements filenames to provide a reference to other elements of interests related to this one: <br/> <code>@see my_element1.py, my element2.py</code></li>
        </ul>
        </p>
        <p>Typically you will need to get access to some fields of a record to display as output. There are two ways to this: you can access the <code>bfo</code> object given as parameter and use the provided (basic) accessors, or import a dedicated module and use its advanced functionalities.</p>
        <p><b>Method 1: Use accessors of <code>bfo</code></b>:<br/>
        <code>bfo</code> is an instance of the <code>BibFormatObject</code> class. The following methods are available:
<ul>
<li><code>get_record()</code>: Returns the record of this BibFormatObject instance as a BibRecord structure. Allows advanced access on the structure using <code>BibRecord</code>.</li>
<li><code>control_field(tag)</code>: Returns the value of control field given by MARC <code>tag</code>.</li>
<li><code>field(tag)</code>:Returns the value of the field corresponding to MARC <code>tag</code>. If the value does not exist, return empty string.</li>
<li><code>fields(tag)</code>: Returns the list of values corresonding to MARC <code>tag</code>.If tag has an undefined subcode (such as 999C5), the function returns a list of dictionaries, whoose keys are the subcodes and the values are the values of tag.subcode. If the tag has a subcode, simply returns list of values corresponding to tag.</li>
<li><code>kb(kb, string, default="")</code>: Returns the value of the <code>string</code> in the knowledge base <code>kb</code>. If kb does not exist or string does not exist in kb, returns <code>default</code> string.
</p>
        <p><b>Method 2: Use module <code>BibRecord</code></b>:<br/>
        BibRecord is a module that provides advanced functionalities regarding access to the field of a record
        <code>bfo.get_record()</code> returns a structure that can be understood by BibRecord's functions. Therefore you can import the module's functions to get access to the fields you want.
        </p>
    <h3><a name="internationalizationFormatElement">Internationalization (i18n)</a></h3>
    <p>You can follow the standard internationalization procedure in use accross CDS Invenio sources. For example the following code will get you the translation for "Welcome" (assuming "Welcome" has been translated):
<pre>
from invenio.messages import gettext_set_language

ln = bfo.ln
_ = gettext_set_language(ln)

translated_welcome =  _("Welcome")
</pre>
</p>
    <p>Notice the access to <code>bfo.ln</code> to get access to the current language of the user. For simpler translations or behaviour depending on the language you can simply check the value <code>bfo.ln</code> to return your custom text.</p>
    <h3><a name="attrsFormatElement">Edit the Attributes of a Format Element</a></h3>
    <p>A format element has mainly four kinds of attributes: <ul>
    <li>Name: it corresponds to the filename of the element.</li>
    <li>Description: the description is in the <code>docstring</code> of the <code>format</code> function (excepted lines prefixed with <code>@param</code> and <code>@see</code>).</li>
    <li>Parameters descriptions: for each parameter of the <code>format</code> function, a line beginning with <code>@param</code> <i>parameter_name</i> and followed by the description of the parameter is present in the <code>docstring</code> of the <code>format</code> function.</li>
    <li>Reference to other elements: one line beginning with <code>@see</code> and followed by a list of comma-separated format elements filenames in the in the <code>docstring</code> of the <code>format</code> function provides a link to related elements.</li>
    </ul>
    </p>
    <h3><a name="dependenciesFormatElement">Check the Dependencies of a Format Element</a></h3>
    <p>There are two ways to check the a </p>
    <h3><a name="validityFormatElement">Check the Validity of a Format Element</a></h3>
     <p>There are two ways to check the validity of an element. The simplest one is to go to the <a href="bibformatadmin.py/format_elements_doc">format elements documentation</a> and click on "Correctness of this element" for the element you want to check.</p>
     <p>The second method to check the validity of an element is through regular Python methods: you can for example import the element in the interactive interpreter and feed it with test parameters. Notice that you will need to build a BibFormatObject instance to pass it to the <code>bfo</code> parameter of the <code>format</code> function of your element.</p>
    <h3><a name="browseDocFormatElement">Browse the Format Elements Documentation</a></h3>
    <p>Go to the <a href="bibformatadmin.py/format_elements_doc">format elements documentation</a>. There is a summary of all available format elements at the top of the page. You can click on an element to go to its detailed description in the second part of the page.</p>
    <p>Each detailed documentation shows you:
    <ul>
    <li>A description of what the element does.<li>
    <li>A list of all parameters you can use for this element.<li>
    <li>For each parameter, a description and the default value when parameter is ommitted.</li>
    <li>A link to a tool to track the dependencies of your element.</li>
    <li>A link to a tool to check the correctness of your element.</li>
    <li>A link to a tool to test your element with custom parameters.</li>
    
    </ul></p>
    <h3><a name="previewFormatElement">Preview a Format Element</a></h3>
    <p>You can play with a format element parameters and see the result of the element directly in the <a href="bibformatadmin.py/format_elements_doc">format elements documentation</a>: for each element, under the section "See also", click on "Test this element". You are redirected to a page where you can enter a value for the parameters. A description is associated with each parameter as well as an indication of the default value of the parameter if you do not provide a custom value. Click on the "Test!" button to see the result of the element with your parameters.</p>
    
<h2><a name="KBs">Knowledge Bases</a></h2>
   <p>Knowledge bases are a way to define easily extendable repositories of mappings. Their use is various, but their main purpose is to get, given a value, the normalized version of this value. For example you may use a knowledge base to hold a list of all ways to abbreviate the name of a journal, and map these abbreviations to the full journal name. This would be useful to get a normalized journal name accross all of your records.</p>
   <p>The knowledge base itself offers no method to do this normalization. It is limited to the archiving of this knowledge. To benefit from the normalization you need to use a format element which is knowledge-base-aware. The element will look by iteself into the knowledge base to format a record. In that way you can extend the formatting capabilities of this element without having to modify it.</p>
    <h3><a name="addKB">Add a Knowledge Base</a></h3>
    <p>To add a knowledge base go to the <a href="bibformatadmin.py/kb_manage">Manage Knowledge Bases</a> administration page.
    At the bottom of the page click on the "Add New Knowledge Base" button. The knowledge base has been created and you are asked to fill in its attribute. See <a href="#attrsKB">Edit the Attributes of a Knowledge Base</a> to learn more about the attributes of knowledge bases.</p>
    <h3><a name="removeKB">Remove a Knowledge Base</a></h3>
    <p>To remove a knowledge base go to the <a href="bibformatadmin.py/kb_manage">Manage Knowledge Bases</a> administration page. Click on the "Delete" button facing the knowledge base you want to remove and confim. The knowledge base and all the mapping it includes are removed.</p>
    <h3><a name="addMappingKB">Add a Mapping</a></h3>
    <p>Go to the <a href="bibformatadmin.py/kb_manage">Manage Knowledge Bases</a> administration page and click on the knowledge base for which you want to add a mapping. Fill in the form of the "Add New Mapping" section on the left of the page with the new mapping, and click on "Add New Mapping". The mapping has been created. Alternatively you can create the mapping without its attributes, and fill them afterward (See <a href="#editMappingKB">Edit a Mapping</a>).<p/>
    <h3><a name="removeMappingKB">Remove a Mapping</a></h3>
    <p>Go to the <a href="bibformatadmin.py/kb_manage">Manage Knowledge Bases</a> administration page and click on the knowledge base for which you want to remove a mapping. Click on the "Delete" button facing the mapping you want to delete.
    <h3><a name="editMappingKB">Edit a Mapping</a></h3>
    <p>Go to the <a href="bibformatadmin.py/kb_manage">Manage Knowledge Bases</a> administration page and click on the knowledge base for which you want to edit a mapping. Locate the mapping in the list. You can click on the column headers to order the list by <i>Map From</i> or by <i>Map To</i> to help you find it. Once you have edited the mapping click on the corresponding "Save" button.
    <h3><a name="attrsKB">Edit the Attributes of a Knowledge Base</a></h3>
    Go to the <a href="bibformatadmin.py/kb_manage">Manage Knowledge Bases</a> administration page and click on the knowledge base you want to edit. In the top menu, click on "Knowledge Base Attributes". You can then give your knowledge base a name and a description. Finally click on the "Update Base Attributes" button.
    <h3><a name="validityKB">Check the Dependencies a Knowledge Base</a></h3>
    To check the dependencies of a knowledge base
    go to the <a href="bibformatadmin.py/kb_manage">Manage Knowledge Bases</a> page, click on
    the knowledge base you want to check, and then in the menu click on "Knowledge Base Dependencies".</p>
    <p>The next page shows you the list of format elements that use this knowledge base.</p>
    <p>Note that some format elements might be omitted.</p>
    
<h2><a name="marcNotation">MARC Notation in Formats</a></h2>
<p>The notation for accessing fields of a record are quite flexible. You can use a syntax strict regarding MARC 21, but also
  a shortcut syntax, or a syntax that can have a special meaning.</p>
  <p>The MARC syntax is the following one:
      <code>tag[indicator1][indicator2] [$ subfield]</code> where <code>tag</code> is 3 digits, <code>indicator1</code> and <code>indicator2</code> are 1 character each, and <code>subfield</code> is 1 letter.
      </p>
  <p>For example to get access to an abstract you can use the MARC notation <code>520 $a</code>. You can use this syntax in BibFormat. However you can also:
      <ul>
      <li>Omit any whitespace character (or use as many as you want)</li>
      <li>Omit the <code>$</code> character (or use as many as you want)</li>
      <li>Omit or use both indicators. You cannot specify only one indicator. If you need to use only one, use underscore <code>_</code> character for the other indicator.</li>
      <li>Use percent <code>%</code> instead of any character to specify all ("don'care" or wildcard character) for that character. </li>
      </ul></p>
<h2><a name="migration">Migrating from Previous BibFormat</a></h2>


<h2><a name="faq">FAQ</a></h2>

<h3>Why do we need output formats? Wouldn't format templates be sufficient?</h3>
<p>As you potentially have a lot of records, it is not conceivable to specify for each of them which
format template they should use. This is why this rule-based decision layer has been introduced.</p>

<h3>How can I protect a format?</h3>
<p>As a web user, you cannot protect a format. If you are administrator of the
system and have access to the format files, you can simply use the permission rights of your system, as BibFormat
is aware of it.</p>

<h3>Why cannot I edit/delete a format?</h3>
<p>The format file has certainly been protected by the administrator of the server. You must ask the
administrator to unprotect the file if you want to edit it.</p>

<h3>How can I add a format element from the web interface?</h3>
<p>Format elements cannot be added, removed or edited through the web interface. This limitation
has been introduced to limit the security risks caused by the upload of Pythonic files on the server. The only possibility to add a basic format element from the web interface is to add a en entry in the "<a href="<WEBURL>/admin/bibindex/bibindexadmin.py/field">Logical Fields</a>" management interface of the BibIndex module (see <a href="#addFormatElement">Add a Format Element</a>)</p>

<h3>Why are some Marc codes omitted in the "Check Dependencies" pages?</h3>
<p>When you check the dependencies of a format, the page reminds you that
some use of Marc codes might not be indicated. This is because it is not
possible (or at least not trivial) to guess that the call to <code>field(str(5+4)+"80"+".a")</code>
is equal to a call to <code>field("980.a")</code>. You should then not completely rely on this indication.</p>


<h3>Why are some format elements omitted in the "Knowledge Base Dependencies" page?<h3>
<p>When you check the dependencies of a knowledge base, the page reminds you that
format elements using this knowledge base might not be indicated. This is because it is not
possible (or at least not trivial) to guess that the call to <code>kb(e.upper()+"journal"+"s")</code> in a format element
is equal to a call to <code>kb("Ejournals")</code>. You should then not completely rely on this indication.</p>

</define-tag>
